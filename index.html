

<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GENCA MPE Ultra Continuum: Hybrid Edition</title>
    <style>
        :root {
            --red: #ff3333;
            --amber: #ffaa00;
            --bg-panel: rgba(20, 20, 20, 0.98);
            --bg-panel-soft: rgba(35, 35, 35, 0.9);
            --btn-bg: #1b1b1b;
            --btn-border: #444;
            --btn-text: #eee;
            --ui-pad: 8px;
            --ui-gap: 6px;
            --ctrl-h: 30px;
            --ctrl-font: 10px;
            --label-font: 8px;
        }
        body { margin: 0; background: #000; color: #eee; font-family: 'Segoe UI', Roboto, sans-serif; overflow: hidden; touch-action: none; }
        #ui { 
            position: absolute; top: 0; left: 0; right: 0; 
            background: linear-gradient(180deg, rgba(30, 30, 30, 0.98), rgba(12, 12, 12, 0.98)); padding: 6px; 
            border-bottom: 2px solid var(--red); display: flex; flex-wrap: wrap; gap: 4px; 
            z-index: 100; transform: translateY(-100%); transition: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #ui.active { transform: translateY(0); }
        #ui select, #ui input, #ui .menu-btn { min-width: 0; }
        #ui .ui-row {
            display: flex;
            flex-wrap: wrap;
            gap: var(--ui-gap);
            width: 100%;
        }
        #ui .ui-advanced { display: none; }
        #ui.show-advanced .ui-advanced { display: flex; }
        #ui .ui-group {
            display: flex;
            gap: 3px;
            padding: 2px 3px;
            border: 1px solid var(--red);
            border-radius: 6px;
            background: var(--bg-panel-soft);
            align-items: center;
            flex-wrap: wrap;
            flex: 1 1 auto;
        }
        #ui label { font-size: 7px; margin-bottom: 1px; }
        #ui select, #ui input, #ui .menu-btn { font-size: 9px; padding: 3px; min-height: 26px; }
        #ui .ui-group.scale-group {
            flex-wrap: wrap;
            align-items: center;
            overflow: hidden;
            gap: 2px;
        }
        #ui .ui-group.scale-group .box {
            min-width: 70px;
            flex: 1 1 70px;
        }
        #ui .ui-group.scale-group .box#scaleRootBox {
            min-width: 44px;
            flex: 0 0 44px;
        }
        #ui .ui-group.scale-group .box#scaleDiatonicBox,
        #ui .ui-group.scale-group .box#scaleMicroBox,
        #ui .ui-group.scale-group .box#scaleCustomBox {
            flex: 1 1 110px;
        }
        #ui .ui-group.scale-group .scale-menu label {
            margin-bottom: 1px;
        }
        #ui .ui-group.scale-group .scale-menu select {
            width: 100%;
        }
        #ui .ui-group.scale-group .microtonalize-row {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-top: 1px;
            font-size: 7px;
            text-transform: none;
            color: #ddd;
        }
        #ui .ui-group.scale-group .custom-scale-row {
            display: grid;
            grid-template-columns: minmax(60px, 1fr) minmax(60px, 1fr) 24px 24px;
            gap: 2px;
            align-items: center;
        }
        #ui .ui-group.scale-group .custom-scale-row .menu-btn {
            min-width: 24px;
            padding: 1px;
        }
        #ui .ui-group.scale-group .custom-mode-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
            align-items: center;
            margin-top: 1px;
        }
        #ui .ui-group.scale-group .custom-mode-item {
            display: grid;
            grid-template-columns: auto minmax(70px, 1fr);
            gap: 2px;
            align-items: center;
        }
        #ui .ui-group.scale-group .custom-scale-input {
            width: 100%;
        }
        #ui .ui-group.scale-group #customScaleSaved,
        #ui .ui-group.scale-group #customScaleName {
            width: 72px !important;
        }
        #ui .ui-title {
            font-size: 7px;
            text-transform: uppercase;
            color: var(--amber);
            font-weight: bold;
            margin-right: 4px;
            letter-spacing: 0.08em;
        }
        #ui .ui-toggle-group { flex: 0 0 auto; }
        #guideBtn.menu-btn,
        #uiAdvancedToggle.menu-btn {
            padding: 2px 6px;
            min-width: 30px;
        }
        .scale-menu[data-scale-choice] {
            cursor: pointer;
        }
        .hidden { display: none; }
        .scale-menu.active {
            outline: 2px solid #ffaa00;
            box-shadow: 0 0 8px rgba(255, 170, 0, 0.5);
        }
        #performance {
            position: fixed; left: 0; right: 0; bottom: 0;
            background: linear-gradient(0deg, rgba(20, 10, 10, 0.98), rgba(6, 6, 6, 0.98));
            border-top: 2px solid var(--red);
            display: flex; gap: 50px; padding: 4px 6px; flex-wrap: nowrap; align-items: center; justify-content: center;
            overflow-x: auto;
            z-index: 110;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #performance button,
        #performance .menu-btn,
        #performance select,
        #performance input { min-height: var(--ctrl-h); }
        #performance.collapsed { transform: translateY(100%); }
        #uiToggle {
            position: fixed;
            top: 8px;
            right: 8px;
            z-index: 120;
        }
        #guideBtn {
            position: fixed;
            top: 8px;
            left: 8px;
            z-index: 120;
        }
        #perfToggle {
            position: fixed;
            right: 8px;
            bottom: 8px;
            z-index: 120;
        }
        #performance .box { min-width: 0; flex: 0 0 auto !important; }
        #performance .menu-btn .short { display: none; }
        #performance .label { display: none; }
        #performance .label.show-label { display: block; }
        #performance .icon-btn {
            display: inline-flex; align-items: center; justify-content: center;
            width: 56px; height: 56px;
            border: 1px solid var(--red); border-radius: 6px;
            background: #1c1c1c; color: #fff; font-weight: bold; font-size: 18px;
        }
        #performance .hold-btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 4px; padding: 0;
            width: 56px; height: 56px; border: 1px solid var(--red); border-radius: 6px;
            background: #1c1c1c; color: #fff; font-weight: bold;
        }
        #performance .hold-btn .led {
            width: 8px; height: 8px; border-radius: 50%;
            background: #222; border: 1px solid #555;
        }
        #performance .hold-btn.active { background: #2a1800; border-color: var(--amber); color: #ffd28a; }
        #performance .hold-btn.active .led { background: #00ff44; border-color: #00ff44; }
        #performance .hold-btn.toggle-off { background: #330000; border-color: var(--red); color: #ffdede; }
        #performance .hold-btn.toggle-on { background: #2a1800; border-color: var(--amber); color: #ffd28a; }
        #performance .panic-btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 4px;
            width: 56px; height: 56px; padding: 0; border: 1px solid #ff3333; border-radius: 6px;
            background: #330000; color: #fff; font-weight: bold;
        }
        #performance .transpose-wrap { display: flex; gap: 8px; align-items: center; }
        #performance .transpose-value { min-width: 36px; text-align: center; font-size: 18px; }
        #performance .chord-toggle {
            display: flex; gap: 50px; justify-content: center;
        }
        #performance .arp-toggle {
            display: flex; gap: 50px; justify-content: center; align-items: center; position: relative;
        }
        #performance .chord-box { flex-direction: row; align-items: center; gap: 3px; text-align: center; }
        #performance #chordMode { display: none; }
        #performance .arp-legacy { display: none; }
        #performance .arp-params.hidden { display: none; }
        .chord-wheel {
            width: 56px; height: 56px;
            border-radius: 50%;
            border: 2px solid var(--red);
            background: radial-gradient(circle at 30% 30%, #3a3a3a, #111);
            display: flex; align-items: center; justify-content: center;
            color: #fff; font-size: 16px; font-weight: bold;
            text-align: center; user-select: none; touch-action: none;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.6);
        }
        .chord-wheel.knob-on { box-shadow: 0 0 10px rgba(255,170,0,0.6); border-color: #ffaa00; }
        .chord-wheel.knob-off { box-shadow: 0 0 8px rgba(255, 60, 60, 0.4); border-color: #ff3333; color: #ffdede; background: radial-gradient(circle at 30% 30%, #4a1a1a, #160606); }
        .chord-wheel.chord-knob::before,
        .chord-wheel.arp-knob::before { content: none; }
        #performance .knob-btn {
            width: 56px;
            height: 56px;
            padding: 0;
            border-radius: 8px;
            font-size: 9px;
        }
        #performance .arp-params { display: flex; align-items: center; gap: 10px; }
        #performance .arp-params label { display: inline; font-size: 8px; margin: 0 2px 0 0; }
        #performance .arp-params {
            min-height: 56px;
            position: static;
            background: rgba(20, 10, 10, 0.98);
            border: 1px solid var(--red);
            border-radius: 8px;
            padding: 6px 8px;
        }
        #performance .toggle-off { background: #330000; border-color: var(--red); color: #ffdede; }
        #performance .toggle-on { background: #2a1800; border-color: var(--amber); color: #ffd28a; }
        .box { display: flex; flex-direction: column; flex: 1 1 80px; min-width: 70px; }
        label { font-size: var(--label-font); text-transform: uppercase; color: var(--amber); margin-bottom: 2px; font-weight: bold; letter-spacing: 0.08em; }
        select, input { background: #2a2a2a; color: #fff; border: 1px solid #444; padding: 4px; font-size: var(--ctrl-font); border-radius: 4px; outline: none; min-height: var(--ctrl-h); }
        input[type="checkbox"] { width: 16px; height: 16px; }
        .oct-ctrl { display: flex; align-items: center; justify-content: space-between; background: #2a2a2a; border: 1px solid #ff3333; border-radius: 4px; height: 28px; }
        .oct-btn { background: #300; color: #fff; border: none; width: 30px; height: 100%; cursor: pointer; font-weight: bold; }
        #octVal { font-size: 12px; color: #fff; width: 25px; text-align: center; }
        #playArea {
            position: absolute;
            top: var(--ui-h, 0px);
            bottom: var(--perf-h, 0px);
            left: 0;
            right: 0;
        }
        canvas { display: block; width: 100%; height: 100%; }
        .footer { position: absolute; bottom: 44px; left: 10px; right: 10px; display: flex; justify-content: space-between; pointer-events: none; font-size: 9px; color: #444; }
        .menu-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            background: var(--btn-bg);
            color: var(--btn-text);
            border: 1px solid var(--btn-border);
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: var(--ctrl-font);
            min-height: var(--ctrl-h);
            min-width: 36px;
        }
        #performance .btn-square {
            width: 56px;
            height: 56px;
            padding: 0;
            border-radius: 6px;
        }
        #performance .knob-btn .btn-text { font-size: 12px; letter-spacing: 0.06em; }
        #performance .fade-wrap { display: inline-flex; align-items: center; gap: 0; }
        #performance #fadeSeconds {
            width: 64px;
            height: 56px;
            border-left: none;
            border-radius: 0 6px 6px 0;
            font-size: 16px;
            text-align: center;
        }
        #performance .fade-sec {
            font-size: 10px;
            color: var(--amber);
            margin-left: 4px;
            letter-spacing: 0.08em;
        }
        #performance #panicBtn .btn-text,
        #performance #fadeBtn .btn-text,
        #performance #holdBtn .btn-text { display: none; }
        #performance #panicBtn .btn-icon,
        #performance #fadeBtn .btn-icon,
        #performance #holdBtn .btn-icon { display: inline; font-size: 20px; }
        #performance .menu-btn.toggle-on { background: #2a1800; border-color: var(--amber); color: #ffd28a; }
        #performance .menu-btn.toggle-off { background: #330000; border-color: var(--red); color: #ffdede; }
        #performance #panicBtn:active,
        #performance #fadeBtn:active {
            background: #2a1800;
            border-color: var(--amber);
            color: #ffd28a;
        }
        button, .menu-btn, select, input[type="range"], input[type="checkbox"] { min-height: var(--ctrl-h); }
        .menu-btn.active { background: #552200; border-color: var(--amber); color: #ffd28a; }
        .menu-btn.btn-accent { background: #2a1800; border-color: var(--amber); color: #ffd28a; }
        .menu-btn.btn-danger { background: #330000; border-color: var(--red); color: #ffdede; }
        .menu-btn.btn-ok { background: #003015; border-color: #00cc55; color: #b4ffd1; }
        .btn-icon { font-size: 12px; line-height: 1; }
        .btn-text { letter-spacing: 0.06em; }
        #ui .box select, #ui .box input { width: 100%; }
        @media (max-width: 600px) {
            #ui { transform: translateY(-100%); max-height: 45vh; overflow-y: auto; -webkit-overflow-scrolling: touch; padding-top: calc(6px + env(safe-area-inset-top)); }
            #ui.active { transform: translateY(0); }
            #uiToggle { top: calc(8px + env(safe-area-inset-top)); }
            #guideBtn { top: calc(8px + env(safe-area-inset-top)); }
            #ui { padding: 6px; gap: 5px; }
            #ui .box { min-width: 64px; }
            #ui label { font-size: 7px; }
            #ui select, #ui input, #ui .menu-btn { font-size: 9px; padding: 3px; }
            #ui .ui-group { width: 100%; flex: 1 1 100%; }
            #ui .ui-title { width: 100%; margin-right: 0; }
            #ui .ui-group .box { flex: 1 1 48%; min-width: 120px; }
            #ui .ui-group .box[style*="flex:1.2"] { flex: 1 1 100%; }
            #performance { gap: 5px; padding: 5px; padding-bottom: calc(6px + env(safe-area-inset-bottom)); }
            #performance .box { min-width: 54px; }
            #performance label { display: none; }
            #performance select, #performance input, #performance .menu-btn { font-size: 9px; padding: 3px; }
            #performance .arp-group { width: 100%; }
            #performance .arp-group .box { flex: 1 1 45%; min-width: 120px; }
            #performance .oct-ctrl { height: 24px; }
            #performance .oct-btn { width: 24px; }
            #performance #octVal { font-size: 10px; width: 20px; }
            #performance .menu-btn .full { display: none; }
            #performance .menu-btn .short { display: inline; }
            #performance .chord-knob { width: 40px; height: 40px; }
            #performance .transpose-value { min-width: 22px; }
            input[type="checkbox"] { width: 14px; height: 14px; }
        }
        @media (max-width: 900px) {
            select, input, .menu-btn { min-height: 28px; }
            .menu-btn { min-width: 44px; }
            input[type="checkbox"] { width: 18px; height: 18px; }
            #performance .icon-btn, #performance .hold-btn, #performance .panic-btn { min-height: 32px; }
        }
        @media (max-width: 480px) {
            #performance { gap: 4px; }
            #performance .box { min-width: 54px; flex: 1 1 54px; }
            #performance .arp-group .box { min-width: 100px; }
            #performance .transpose-wrap { gap: 4px; }
            #performance .chord-wheel { width: 52px; height: 52px; }
            #perfToggle { bottom: calc(8px + env(safe-area-inset-bottom)); }
        }
    </style>
</head>
<body>

<a id="guideBtn" class="menu-btn btn-accent" href="USER_MANUAL.md" target="_blank" rel="noopener" title="Open Guide"><span class="btn-text">GUIDE</span></a>
<button id="uiToggle" class="menu-btn btn-accent" title="Toggle UI"><span class="btn-text">SET ARP</span></button>
<button id="perfToggle" class="menu-btn btn-accent" title="Toggle Performance"><span class="btn-text">PLAY</span></button>

<div id="ui">
    <div class="ui-row ui-quick">
    <div class="ui-group ui-toggle-group">
        <div class="ui-title">View</div>
        <button id="uiAdvancedToggle" class="menu-btn btn-accent" title="Advanced"><span class="btn-text">ADV</span></button>
    </div>
    <div class="ui-group">
        <div class="ui-title">MIDI</div>
        <div class="box" style="flex:1.2"><label>MIDI In</label><select id="midiInSelect" data-param="midiInSelect"><option value="">Nessun Input</option></select></div>
        <div class="box" style="flex:1.2"><label>MIDI Out</label><select id="midiOutSelect" data-param="midiOutSelect"></select></div>
        <div class="box" style="flex:0.4"><label>Thru</label><input type="checkbox" id="midiThru" data-param="midiThru"></div>
    </div>
    <div class="ui-group scale-group">
        <div class="ui-title">Scale</div>
        <div class="hidden">
            <input type="radio" name="scaleMode" value="diatonic" id="scaleModeDiatonic" checked>
            <input type="radio" name="scaleMode" value="microtonal" id="scaleModeMicro">
            <input type="radio" name="scaleMode" value="custom" id="scaleModeCustom">
        </div>
        <div class="box" id="scaleRootBox" style="flex:0.5">
            <label>Root</label>
            <select id="rootNote" style="width:45px;" data-param="rootNote">
                <option value="0">C</option><option value="1">C#</option><option value="2">D</option><option value="3">D#</option>
                <option value="4">E</option><option value="5">F</option><option value="6">F#</option><option value="7">G</option>
                <option value="8">G#</option><option value="9">A</option><option value="10">A#</option><option value="11">B</option>
            </select>
        </div>
        <div class="box" style="flex:0.7"><label>Octaves</label>
            <select id="visibleOctaves" data-param="visibleOctaves">
                <option value="1" selected>1 Oct</option>
                <option value="2">2 Oct</option>
                <option value="3">3 Oct</option>
                <option value="4">4 Oct</option>
            </select>
        </div>
        <div class="box scale-menu" id="scaleDiatonicBox" style="flex:1.1" data-scale-choice="diatonic"><label>Diatonic Scales</label>
            <select id="scaleType" data-param="scaleType">
                <option value="chromatic">Chromatic</option>
                <option value="major">Major</option><option value="minor">Minor</option>
                <option value="dorian">Dorian</option><option value="phrygian">Phrygian</option>
                <option value="lydian">Lydian</option><option value="mixolydian">Mixolydian</option>
                <option value="locrian">Locrian</option><option value="harmonicMinor">Harmonic Min</option>
                <option value="melodicMinor">Melodic Min</option><option value="pentatonicMaj">Pentatonic Maj</option>
                <option value="pentatonicMin">Pentatonic Min</option><option value="blues">Blues</option>
                <option value="hirajoshi">Hirajoshi (Jap)</option><option value="bhairav">Bhairav (Ind)</option>
                <option value="arabic">Arabic</option><option value="wholeTone">Whole Tone</option>
                <option value="diminished">Diminished</option>
            </select>
        </div>
        <div class="box scale-menu" id="scaleMicroBox" style="flex:1.1" data-scale-choice="microtonal"><label>Microtonal Scales</label>
            <select id="microScaleSelect"></select>
            <label class="microtonalize-row">
                <input type="checkbox" id="microtonalizeIn"> Microtonalize MIDI In (MPE)
            </label>
        </div>
        <div class="box scale-menu" id="scaleCustomBox" style="flex:1.3" data-scale-choice="custom"><label>Custom Scales</label>
            <div class="custom-scale-row">
                <select id="customScaleSaved" style="min-width:90px;">
                    <option value="">(saved)</option>
                </select>
                <input type="text" id="customScaleName" placeholder="Name" style="width:90px;" list="customScaleNames">
                <button id="customScaleSave" class="menu-btn btn-ok" aria-label="Save"><span class="btn-icon">üíæ</span></button>
                <button id="customScaleDel" class="menu-btn btn-danger" aria-label="Delete"><span class="btn-icon">üóë</span></button>
            </div>
            <div class="custom-mode-row">
                <div class="custom-mode-item">
                    <label style="font-size:10px; text-transform:none; color:#ddd; margin:0;">
                        <input type="radio" name="customScaleMode" value="notes" id="customModeNotes" checked> Notes
                    </label>
                    <input type="text" id="customScaleNotes" placeholder="Notes list (C, D#, F...)" class="custom-scale-input">
                </div>
                <div class="custom-mode-item">
                    <label style="font-size:10px; text-transform:none; color:#ddd; margin:0;">
                        <input type="radio" name="customScaleMode" value="cents" id="customModeCents"> Cents
                    </label>
                    <input type="text" id="customScaleCents" placeholder="Cents list (0, 240, 480...)" class="custom-scale-input">
                </div>
            </div>
            <datalist id="customScaleNames"></datalist>
        </div>
        
    </div>
    <div class="ui-group">
        <div class="ui-title">Chord</div>
        <div class="box" style="flex:0.6"><label>Inversion</label><select id="chordInversion" data-param="chordInversion">
            <option value="0">Root</option><option value="1">1st</option><option value="2">2nd</option><option value="3">3rd</option>
        </select></div>
        <div class="box" style="flex:0.6"><label>Spread</label><input type="range" id="chordSpread" min="0" max="12" value="0" data-param="chordSpread"></div>
    </div>
    </div>
    <div class="ui-row ui-advanced">
    <div class="ui-group">
        <div class="ui-title">MPE</div>
        <div class="box" style="flex:0.5"><label>PB Range</label><select id="pbRange" data-param="pbRange">
            <option value="2">+/-2</option><option value="12">+/-12</option><option value="24">+/-24</option><option value="48" selected>+/-48</option>
        </select></div>
        <div class="box" style="flex:0.5"><label>Snap</label><input type="range" id="roundRate" min="0" max="80" value="80" data-param="roundRate"></div>
        <div class="box" style="flex:0.4"><label>Dead-Center</label><input type="checkbox" id="deadCenter" data-param="deadCenter" checked></div>
        <div class="box" style="flex:0.5"><label>DC Force</label><input type="range" id="deadCenterForce" min="0" max="100" value="100" data-param="deadCenterForce"></div>
        <div class="box" style="flex:0.4"><label>Link YZ</label><input type="checkbox" id="linkPressToY" checked data-param="linkPressToY"></div>
        <div class="box" style="flex:0.5"><label>Y Vel</label><input type="checkbox" id="linkYToVelocity" checked data-param="linkYToVelocity"></div>
        <div class="box" style="flex:0.5"><label>Smooth</label><input type="range" id="smoothAmt" min="0" max="100" value="20" data-param="smoothAmt"></div>
        <div class="box" style="flex:0.5"><label>Curve</label>
            <select id="curveType" data-param="curveType">
                <option value="linear" selected>Linear</option>
                <option value="soft">Soft</option>
                <option value="hard">Hard</option>
            </select>
        </div>
        <div class="box" style="flex:0.5"><label>Y Deadzone</label><input type="range" id="yDeadzone" min="0" max="30" value="5" data-param="yDeadzone"></div>
        <div class="box" style="flex:0.5"><label>Q Release</label><input type="checkbox" id="quantizeRelease" data-param="quantizeRelease" checked></div>
        <div class="box" style="flex:1.2"><label>MPE Preset</label>
            <div style="display:flex; gap:2px;">
                <select id="mpePresetSelect" style="min-width:90px;"></select>
                <input type="text" id="mpePresetName" placeholder="Name" style="width:70px;">
                <button id="mpePresetSave" class="menu-btn btn-ok" aria-label="Save"><span class="btn-icon">üíæ</span></button>
                <button id="mpePresetDel" class="menu-btn btn-danger" aria-label="Delete"><span class="btn-icon">üóë</span></button>
            </div>
            <div id="mpePresetDesc" style="font-size:8px; color:#888; margin-top:2px;">&nbsp;</div>
        </div>
    </div>
    <div class="ui-group">
        <div class="ui-title">Global Preset</div>
        <div class="box" style="flex:1.2"><label>Preset</label>
            <div style="display:flex; gap:2px;">
                <select id="presetSelect" style="min-width:90px;" data-param="presetSelect"></select>
                <input type="text" id="presetName" placeholder="Name" style="width:70px;">
                <button id="presetSave" class="menu-btn btn-ok" aria-label="Save"><span class="btn-icon">üíæ</span></button>
                <button id="presetDel" class="menu-btn btn-danger" aria-label="Delete"><span class="btn-icon">üóë</span></button>
            </div>
            <div id="presetDesc" style="font-size:8px; color:#888; margin-top:2px;">&nbsp;</div>
        </div>
    </div>
    <div class="ui-group">
        <div class="ui-title">System</div>
        <div class="box" style="flex:0.4"><label>Full</label><button id="fsBtn" class="menu-btn btn-accent" title="Full Screen"><span class="btn-icon">‚õ∂</span><span class="btn-text">FS</span></button></div>
    </div>
</div>
</div>

<div id="performance">
    <div class="box" style="flex:0.7">
        <div class="label">Transpose</div>
        <div class="transpose-wrap">
            <button class="icon-btn" id="octDownBtn" title="Oct -">&lt;</button>
            <div class="transpose-value" id="octVal">0</div>
            <button class="icon-btn" id="octUpBtn" title="Oct +">&gt;</button>
        </div>
    </div>
    <div class="box chord-box" style="flex:0.9">
        <div class="label show-label">GROUP</div>
        <button id="groupShiftBtn" class="menu-btn btn-accent btn-square toggle-off" title="Group Shift">
            <span class="btn-text">GROUP</span>
        </button>
    </div>
    <div class="box chord-box" style="flex:1.1">
        <div class="label show-label">Chords</div>
        <div class="chord-toggle">
            <div id="chordWheel" class="chord-wheel chord-knob" title="Rotate to change chord">Choose</div>
        </div>
        <select id="chordMode" title="Chords" data-param="chordMode">
        <option value="off">Off</option>
        <option value="auto">Auto (Diatonic)</option>
        <option value="auto7">Auto (Diatonic 7th)</option>
        <option value="power">Power 5</option>
        <option value="triad">Triad (Maj)</option>
        <option value="minTriad">Triad (Min)</option>
        <option value="dimTriad">Triad (Dim)</option>
        <option value="augTriad">Triad (Aug)</option>
        <option value="sus2">Sus2</option>
        <option value="sus4">Sus4</option>
        <option value="add9">Add9</option>
        <option value="sixth">6th</option>
        <option value="seventh">7th (Dom)</option>
        <option value="maj7">Maj7</option>
        <option value="min7">Min7</option>
        <option value="halfDim7">7th (Half-Dim)</option>
        <option value="dim7">7th (Dim)</option>
        <option value="dom9">Dom9</option>
        <option value="maj9">Maj9</option>
        <option value="min9">Min9</option>
        <option value="eleventh">11th</option>
        <option value="thirteenth">13th</option>
        </select>
    </div>
    <div class="box chord-box" style="flex:0.9">
        <div class="label show-label">HOLD</div>
        <button id="holdBtn" class="hold-btn" title="Hold"><span class="led"></span><span class="btn-icon">‚è∏</span><span class="btn-text">HOLD</span></button>
        <input type="checkbox" id="holdNotes" style="display:none" data-param="holdNotes">
    </div>
    <div class="box chord-box" style="flex:0.9">
        <div class="label show-label">STOP</div>
        <button id="panicBtn" class="menu-btn btn-danger btn-square toggle-off" title="Stop"><span class="btn-icon">‚èπ</span><span class="btn-text">STOP</span></button>
    </div>
    <div class="box chord-box" style="flex:0.9">
        <div class="label show-label">FADE</div>
        <div class="fade-wrap">
            <button id="fadeBtn" class="menu-btn btn-accent btn-square toggle-off" title="Fade Out"><span class="btn-icon">‚á£</span><span class="btn-text">FADE</span></button>
            <input type="number" id="fadeSeconds" min="1" max="20" value="4">
            <div class="fade-sec">sec</div>
        </div>
    </div>
    <div class="box chord-box" style="flex:1.1">
        <div class="label show-label">ARP</div>
        <div class="arp-toggle">
            <div id="arpWheel" class="chord-wheel arp-knob" title="Rotate to change rate">1/16</div>
            <button id="arpParamsToggle" class="menu-btn btn-accent knob-btn" title="ARP Settings"><span class="btn-text">SET ARP</span></button>
            <div id="arpParamsPanel" class="arp-params hidden">
            <label for="arpGate">Gate</label>
            <input type="range" id="arpGate" min="10" max="100" value="60" data-param="arpGate">
            <label for="arpSync">Sync</label>
            <select id="arpSync" data-param="arpSync">
                <option value="internal" selected>Internal</option>
                <option value="midi">MIDI</option>
            </select>
            <label for="arpBpm">BPM</label>
            <input type="number" id="arpBpm" min="40" max="240" value="120" data-param="arpBpm">
            </div>
        </div>
    </div>
    <input type="checkbox" id="arpEnabled" data-param="arpEnabled" style="display:none">
    <input type="checkbox" id="arpLatch" data-param="arpLatch" style="display:none">
    <select id="arpRate" data-param="arpRate" style="display:none">
        <option value="1/4">1/4</option>
        <option value="1/8">1/8</option>
        <option value="1/8T">1/8T</option>
        <option value="1/16" selected>1/16</option>
        <option value="1/16T">1/16T</option>
        <option value="1/32">1/32</option>
    </select>
</div>

<div id="playArea">
    <canvas id="surface"></canvas>
    <div class="footer">
        <div id="midiStatus">HYBRID ENGINE READY</div>
        <div>SPOSTA GIU' PER IL MENU</div>
    </div>
</div>

<script>
const canvas = document.getElementById('surface');
const ctx = canvas.getContext('2d');
const CANVAS_FONT_FAMILY = "'Segoe UI', Roboto, sans-serif";
const els = {
    ui: document.getElementById('ui'),
    performance: document.getElementById('performance'),
    uiAdvancedToggle: document.getElementById('uiAdvancedToggle'),
    midiInSelect: document.getElementById('midiInSelect'),
    midiOutSelect: document.getElementById('midiOutSelect'),
    rootNote: document.getElementById('rootNote'),
    scaleType: document.getElementById('scaleType'),
    microScaleSelect: document.getElementById('microScaleSelect'),
    microtonalizeIn: document.getElementById('microtonalizeIn'),
    visibleOctaves: document.getElementById('visibleOctaves'),
    scaleModeDiatonic: document.getElementById('scaleModeDiatonic'),
    scaleModeMicro: document.getElementById('scaleModeMicro'),
    scaleModeCustom: document.getElementById('scaleModeCustom'),
    scaleDiatonicBox: document.getElementById('scaleDiatonicBox'),
    scaleMicroBox: document.getElementById('scaleMicroBox'),
    scaleCustomBox: document.getElementById('scaleCustomBox'),
    customModeNotes: document.getElementById('customModeNotes'),
    customModeCents: document.getElementById('customModeCents'),
    chordMode: document.getElementById('chordMode'),
    chordInversion: document.getElementById('chordInversion'),
    chordSpread: document.getElementById('chordSpread'),
    pbRange: document.getElementById('pbRange'),
    midiThru: document.getElementById('midiThru'),
    roundRate: document.getElementById('roundRate'),
    deadCenter: document.getElementById('deadCenter'),
    deadCenterForce: document.getElementById('deadCenterForce'),
    linkPressToY: document.getElementById('linkPressToY'),
    linkYToVelocity: document.getElementById('linkYToVelocity'),
    smoothAmt: document.getElementById('smoothAmt'),
    curveType: document.getElementById('curveType'),
    yDeadzone: document.getElementById('yDeadzone'),
    quantizeRelease: document.getElementById('quantizeRelease'),
    customScaleName: document.getElementById('customScaleName'),
    customScaleSaved: document.getElementById('customScaleSaved'),
    customScaleSave: document.getElementById('customScaleSave'),
    customScaleDel: document.getElementById('customScaleDel'),
    customScaleNotes: document.getElementById('customScaleNotes'),
    customScaleCents: document.getElementById('customScaleCents'),
    customScaleNames: document.getElementById('customScaleNames'),
    presetSelect: document.getElementById('presetSelect'),
    presetName: document.getElementById('presetName'),
    presetSave: document.getElementById('presetSave'),
    presetDel: document.getElementById('presetDel'),
    presetDesc: document.getElementById('presetDesc'),
    mpePresetSelect: document.getElementById('mpePresetSelect'),
    mpePresetName: document.getElementById('mpePresetName'),
    mpePresetSave: document.getElementById('mpePresetSave'),
    mpePresetDel: document.getElementById('mpePresetDel'),
    mpePresetDesc: document.getElementById('mpePresetDesc'),
    fsBtn: document.getElementById('fsBtn'),
    arpEnabled: document.getElementById('arpEnabled'),
    arpRate: document.getElementById('arpRate'),
    arpGate: document.getElementById('arpGate'),
    arpSync: document.getElementById('arpSync'),
    arpBpm: document.getElementById('arpBpm'),
    arpLatch: document.getElementById('arpLatch'),
    octDownBtn: document.getElementById('octDownBtn'),
    octUpBtn: document.getElementById('octUpBtn'),
    octVal: document.getElementById('octVal'),
    holdBtn: document.getElementById('holdBtn'),
    holdNotes: document.getElementById('holdNotes'),
    panicBtn: document.getElementById('panicBtn'),
    fadeBtn: document.getElementById('fadeBtn'),
    fadeSeconds: document.getElementById('fadeSeconds'),
    chordWheel: document.getElementById('chordWheel'),
    arpWheel: document.getElementById('arpWheel'),
    arpParamsToggle: document.getElementById('arpParamsToggle'),
    arpParamsPanel: document.getElementById('arpParamsPanel'),
    groupShiftBtn: document.getElementById('groupShiftBtn'),
    midiStatus: document.getElementById('midiStatus')
};
const PRESET_KEY = 'genca_presets_v1';
const MPE_PRESET_KEY = 'genca_mpe_presets_v1';
const CUSTOM_SCALE_KEY = 'genca_custom_scales_v1';
const MICROTONAL_SCALES = {
    'Balinese Slendro': { cents: [0, 240, 480, 720, 960] },
    'Balinese Pelog': { cents: [0, 150, 350, 550, 700, 900, 1050] },
    'Just Major (5-limit)': { cents: [0, 204, 386, 498, 702, 884, 1088] },
    'Just Minor (5-limit)': { cents: [0, 204, 316, 498, 702, 814, 1018] },
    'Maqam Rast': { cents: [0, 204, 350, 498, 702, 904, 1050] },
    '19-TET': { cents: makeEqualTemperament(19) },
    '24-TET': { cents: makeEqualTemperament(24) },
    '31-TET': { cents: makeEqualTemperament(31) }
};
const DEFAULT_CUSTOM_SCALES = {
    'Custom 1': { type: 'cents', cents: [0, 240, 480, 720, 960] }
};
const LOCAL_SUPPRESS_MS = 30;
const GHOST_NOTE_MS = 220;
const state = {
    midi: { output: null, input: null, access: null },
    currentOctave: 0,
    perfHeight: 0,
    canvasRect: canvas.getBoundingClientRect(),
    activeTouches: new Map(),
    physicalNotes: new Map(),
    mpeChannels: Array.from({length: 15}, (_, i) => i + 2),
    localNoteOnTimes: new Map(),
    externalNoteMap: new Map(),
    groupDragStates: new Map(),
    presets: {},
    mpePresets: {},
    customScales: {},
    scaleNotes: { notes: [], root: 0, scale: '' },
    gridCache: null,
    groupShiftEnabled: false,
    fadeState: { active: false, start: 0, durationMs: 0 },
    drawRaf: null,
    scaleUpdateRaf: null,
    fadeTimer: null,
    heldVoices: [],
    arpHoldTouches: [],
    arpColorIndex: 0,
    holdGroupSeq: 1
};
const FADE_TAIL_MS = 200;
const FADE_EASE_POW = 2.2;
const ECHO_TAIL_STEPS = 7;
const ECHO_INTERVAL_MS = 140;
const ECHO_NOTE_MS = 90;
const ECHO_DECAY = 0.75;
const FADE_ECHO_ENABLED = true;
const PRESET_DESCRIPTIONS = {
    Init: 'Default baseline settings.',
    Ableton: 'Studio-friendly sync: MIDI clock ARP and cleaner control.',
    Expressive: 'Loose feel with minimal snap and magnetism.',
    Tight: 'High precision snap and strong dead-center.',
    Glide: 'Free pitch glide with no snap or dead-center.'
};
const MPE_PRESET_DESCRIPTIONS = {
    Expressive: 'Loose feel with minimal snap and magnetism.',
    Tight: 'High precision snap and strong dead-center.',
    Glide: 'Free pitch glide with no snap or dead-center.'
};
state.arp = {
    enabled: false,
    rate: '1/16',
    gate: 0.6,
    sync: 'internal',
    bpm: 120,
    hold: false,
    latch: false,
    running: false,
    stepIndex: 0,
    notes: [],
    active: [],
    timer: null,
    clockTicks: 0,
    ticksPerStep: 6,
    lastClockTime: 0,
    tickMs: 0
};

const SCALES = {
    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], major: [0, 2, 4, 5, 7, 9, 11],
    dorian: [0, 2, 3, 5, 7, 9, 10], phrygian: [0, 1, 3, 5, 7, 8, 10], lydian: [0, 2, 4, 6, 7, 9, 11],
    mixolydian: [0, 2, 4, 5, 7, 9, 10], minor: [0, 2, 3, 5, 7, 8, 10], locrian: [0, 1, 3, 5, 6, 8, 10],
    harmonicMinor: [0, 2, 3, 5, 7, 8, 11], melodicMinor: [0, 2, 3, 5, 7, 9, 11],
    pentatonicMaj: [0, 2, 4, 7, 9], pentatonicMin: [0, 3, 5, 7, 10], blues: [0, 3, 5, 6, 7, 10],
    hirajoshi: [0, 2, 3, 7, 8], bhairav: [0, 1, 4, 5, 7, 8, 11], arabic: [0, 1, 4, 5, 7, 8, 11],
    wholeTone: [0, 2, 4, 6, 8, 10], diminished: [0, 2, 3, 5, 6, 8, 9, 11]
};
const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
const CHORDS = {
    off: [0],
    power: [0, 7],
    triad: [0, 4, 7],
    minTriad: [0, 3, 7],
    dimTriad: [0, 3, 6],
    augTriad: [0, 4, 8],
    sus2: [0, 2, 7],
    sus4: [0, 5, 7],
    add9: [0, 4, 7, 14],
    sixth: [0, 4, 7, 9],
    seventh: [0, 4, 7, 10],
    maj7: [0, 4, 7, 11],
    min7: [0, 3, 7, 10],
    halfDim7: [0, 3, 6, 10],
    dim7: [0, 3, 6, 9],
    dom9: [0, 4, 7, 10, 14],
    maj9: [0, 4, 7, 11, 14],
    min9: [0, 3, 7, 10, 14],
    eleventh: [0, 4, 7, 10, 14, 17],
    thirteenth: [0, 4, 7, 10, 14, 17, 21]
};

function setPitchBendRange(semitones) {
    if (!state.midi.output) return;
    for (let ch = 0; ch < 16; ch++) {
        state.midi.output.send([0xB0 + ch, 101, 0]);
        state.midi.output.send([0xB0 + ch, 100, 0]);
        state.midi.output.send([0xB0 + ch, 6, semitones]);
        state.midi.output.send([0xB0 + ch, 38, 0]);
        state.midi.output.send([0xB0 + ch, 101, 127]);
        state.midi.output.send([0xB0 + ch, 100, 127]);
    }
}

function releaseHeldNotes() {
    if (!state.midi.output) return;
    state.heldVoices.forEach(v => {
        sendMidi([0x80 + v.chan - 1, v.note, 0]);
        state.mpeChannels.push(v.chan);
    });
    state.heldVoices = [];
    state.mpeChannels.sort((a,b)=>a-b);
}

function allNotesOff() {
    if (!state.midi.output) return;
    for (let ch = 0; ch < 16; ch++) {
        state.midi.output.send([0xB0 + ch, 123, 0]);
        state.midi.output.send([0xB0 + ch, 120, 0]);
    }
    state.activeTouches.clear();
    state.physicalNotes.clear();
    state.mpeChannels.splice(0, state.mpeChannels.length, ...Array.from({length: 15}, (_, i) => i + 2));
    state.heldVoices = [];
    state.arpHoldTouches = [];
    state.arp.notes = [];
    stopAllArpNotes();
}

function applyChordVoicing(notes, inversion, spread) {
    const result = notes.slice(0);
    const inv = Math.min(inversion, Math.max(0, result.length - 1));
    for (let i = 0; i < inv; i++) {
        const n = result.shift();
        result.push(n + 12);
    }
    for (let i = 0; i < result.length; i++) {
        result[i] += i * spread;
    }
    return result;
}

function nextArpColor() {
    const hue = (state.arpColorIndex * 137.5) % 360;
    state.arpColorIndex = (state.arpColorIndex + 1) % 10000;
    return `hsl(${hue.toFixed(1)}, 85%, 55%)`;
}

function getPresetState() {
    return {
        rootNote: els.rootNote.value,
        scaleType: els.scaleType.value,
        scaleMode: els.scaleModeDiatonic.checked ? 'diatonic' : (els.scaleModeMicro.checked ? 'microtonal' : 'custom'),
        microScaleName: els.microScaleSelect.value,
        customScaleName: els.customScaleName.value,
        customScaleMode: els.customModeNotes.checked ? 'notes' : 'cents',
        customScaleNotes: els.customScaleNotes.value,
        customScaleCents: els.customScaleCents.value,
        microtonalizeIn: els.microtonalizeIn.checked,
        visibleOctaves: els.visibleOctaves.value,
        chordMode: els.chordMode.value,
        chordInversion: els.chordInversion.value,
        chordSpread: els.chordSpread.value,
        roundRate: els.roundRate.value,
        deadCenter: els.deadCenter.checked,
        deadCenterForce: els.deadCenterForce.value,
        midiOutId: els.midiOutSelect.value || "",
        midiInId: els.midiInSelect.value || "",
        linkPressToY: els.linkPressToY.checked,
        linkYToVelocity: els.linkYToVelocity.checked,
        smoothAmt: els.smoothAmt.value,
        curveType: els.curveType.value,
        yDeadzone: els.yDeadzone.value,
        quantizeRelease: els.quantizeRelease.checked,
        holdNotes: els.holdNotes.checked,
        pbRange: els.pbRange.value,
        midiThru: els.midiThru.checked,
        arpEnabled: els.arpEnabled.checked,
        arpRate: els.arpRate.value,
        arpGate: els.arpGate.value,
        arpSync: els.arpSync.value,
        arpBpm: els.arpBpm.value,
        arpLatch: els.arpLatch.checked,
        currentOctave: state.currentOctave
    };
}

function applyPresetState(presetState) {
    if (!presetState) return;
    els.rootNote.value = presetState.rootNote;
    els.scaleType.value = presetState.scaleType;
    if (presetState.scaleMode === 'microtonal') {
        els.scaleModeMicro.checked = true;
    } else if (presetState.scaleMode === 'custom') {
        els.scaleModeCustom.checked = true;
    } else {
        els.scaleModeDiatonic.checked = true;
    }
    if (presetState.microScaleName && MICROTONAL_SCALES[presetState.microScaleName]) {
        els.microScaleSelect.value = presetState.microScaleName;
    }
    els.microtonalizeIn.checked = !!presetState.microtonalizeIn;
    if (presetState.customScaleName) {
        els.customScaleName.value = presetState.customScaleName;
        if (state.customScales[presetState.customScaleName]) {
            if (state.customScales[presetState.customScaleName].type === 'notes') {
                els.customModeNotes.checked = true;
                els.customScaleNotes.value = formatNotesList(state.customScales[presetState.customScaleName].degrees || []);
            } else {
                els.customModeCents.checked = true;
                els.customScaleCents.value = formatCentsList(state.customScales[presetState.customScaleName].cents || []);
            }
        }
    }
    if (presetState.customScaleMode === 'notes') {
        els.customModeNotes.checked = true;
        if (presetState.customScaleNotes) els.customScaleNotes.value = presetState.customScaleNotes;
    } else if (presetState.customScaleMode === 'cents') {
        els.customModeCents.checked = true;
        if (presetState.customScaleCents) els.customScaleCents.value = presetState.customScaleCents;
    }
    els.visibleOctaves.value = presetState.visibleOctaves;
    els.chordMode.value = presetState.chordMode;
    els.chordMode.dispatchEvent(new Event('change'));
    els.chordInversion.value = presetState.chordInversion;
    els.chordSpread.value = presetState.chordSpread;
    els.roundRate.value = presetState.roundRate;
    els.deadCenter.checked = presetState.deadCenter;
    els.deadCenterForce.value = presetState.deadCenterForce;
    if (state.midi.access) {
        if (presetState.midiOutId && state.midi.access.outputs.has(presetState.midiOutId)) {
            els.midiOutSelect.value = presetState.midiOutId;
            state.midi.output = state.midi.access.outputs.get(presetState.midiOutId);
        }
        if (presetState.midiInId && state.midi.access.inputs.has(presetState.midiInId)) {
            els.midiInSelect.value = presetState.midiInId;
            if (state.midi.input) state.midi.input.onmidimessage = null;
            state.midi.input = state.midi.access.inputs.get(presetState.midiInId);
            if (state.midi.input) state.midi.input.onmidimessage = handleExternalMIDI;
        }
    }
    els.linkPressToY.checked = presetState.linkPressToY;
    els.linkYToVelocity.checked = presetState.linkYToVelocity ?? els.linkYToVelocity.checked;
    els.smoothAmt.value = presetState.smoothAmt ?? els.smoothAmt.value;
    els.curveType.value = presetState.curveType ?? els.curveType.value;
    els.yDeadzone.value = presetState.yDeadzone ?? els.yDeadzone.value;
    els.quantizeRelease.checked = presetState.quantizeRelease ?? els.quantizeRelease.checked;
    els.holdNotes.checked = presetState.holdNotes;
    updateHoldButtonUI();
    els.pbRange.value = presetState.pbRange;
    els.midiThru.checked = presetState.midiThru;
    els.arpEnabled.checked = !!presetState.arpEnabled;
    els.arpRate.value = presetState.arpRate ?? els.arpRate.value;
    els.arpGate.value = presetState.arpGate ?? els.arpGate.value;
    els.arpSync.value = presetState.arpSync ?? els.arpSync.value;
    els.arpBpm.value = presetState.arpBpm ?? els.arpBpm.value;
    els.arpLatch.checked = !!presetState.arpLatch;
    state.currentOctave = presetState.currentOctave || 0;
    els.octVal.innerText = (state.currentOctave > 0 ? "+" : "") + state.currentOctave;
    setPitchBendRange(parseInt(presetState.pbRange, 10));
    if (!presetState.holdNotes) releaseHeldNotes();
    updateScaleNotes();
    syncArpFromUI();
    updateScaleModeUI();
}

function loadPresets() {
    const raw = localStorage.getItem(PRESET_KEY);
    return safeParseJson(raw, {});
}

function savePresets(presets) {
    localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
}

function loadCustomScales() {
    const raw = localStorage.getItem(CUSTOM_SCALE_KEY);
    return safeParseJson(raw, {});
}

function saveCustomScales(scales) {
    localStorage.setItem(CUSTOM_SCALE_KEY, JSON.stringify(scales));
}

function parseCentsList(input) {
    if (!input) return [];
    const parts = input.split(/[\s,]+/).filter(Boolean);
    const cents = parts
        .map(p => Number(p))
        .filter(n => Number.isFinite(n))
        .map(n => Math.max(0, Math.min(1200, n)))
        .filter(n => n < 1200);
    const unique = Array.from(new Set(cents)).sort((a, b) => a - b);
    if (!unique.length || unique[0] !== 0) unique.unshift(0);
    return unique;
}

function formatCentsList(cents) {
    return cents.map(c => String(Math.round(c))).join(', ');
}

function makeEqualTemperament(steps) {
    const cents = [];
    for (let i = 0; i < steps; i++) {
        cents.push(Math.round((i * 1200) / steps));
    }
    return cents;
}

function parseNotesList(input) {
    if (!input) return [];
    const raw = input.split(/[\s,]+/).filter(Boolean);
    const map = {
        'C': 0, 'C#': 1, 'DB': 1,
        'D': 2, 'D#': 3, 'EB': 3,
        'E': 4, 'FB': 4, 'E#': 5,
        'F': 5, 'F#': 6, 'GB': 6,
        'G': 7, 'G#': 8, 'AB': 8,
        'A': 9, 'A#': 10, 'BB': 10,
        'B': 11, 'CB': 11, 'B#': 0
    };
    const degrees = [];
    raw.forEach(token => {
        const t = token.toUpperCase().replace(/\s+/g, '');
        if (map.hasOwnProperty(t)) {
            if (!degrees.includes(map[t])) degrees.push(map[t]);
        }
    });
    if (!degrees.length || degrees[0] !== 0) degrees.unshift(0);
    return degrees;
}

function formatNotesList(degrees) {
    return degrees.map(d => NOTE_NAMES[(d + 12) % 12]).join(', ');
}

function getMpePresetState() {
    return {
        pbRange: els.pbRange.value,
        roundRate: els.roundRate.value,
        deadCenter: els.deadCenter.checked,
        deadCenterForce: els.deadCenterForce.value,
        linkPressToY: els.linkPressToY.checked,
        linkYToVelocity: els.linkYToVelocity.checked,
        smoothAmt: els.smoothAmt.value,
        curveType: els.curveType.value,
        yDeadzone: els.yDeadzone.value,
        quantizeRelease: els.quantizeRelease.checked
    };
}

function applyMpePresetState(mpePresetState) {
    if (!mpePresetState) return;
    els.pbRange.value = mpePresetState.pbRange ?? els.pbRange.value;
    els.roundRate.value = mpePresetState.roundRate ?? els.roundRate.value;
    els.deadCenter.checked = !!mpePresetState.deadCenter;
    els.deadCenterForce.value = mpePresetState.deadCenterForce ?? els.deadCenterForce.value;
    els.linkPressToY.checked = mpePresetState.linkPressToY ?? els.linkPressToY.checked;
    els.linkYToVelocity.checked = mpePresetState.linkYToVelocity ?? els.linkYToVelocity.checked;
    els.smoothAmt.value = mpePresetState.smoothAmt ?? els.smoothAmt.value;
    els.curveType.value = mpePresetState.curveType ?? els.curveType.value;
    els.yDeadzone.value = mpePresetState.yDeadzone ?? els.yDeadzone.value;
    els.quantizeRelease.checked = mpePresetState.quantizeRelease ?? els.quantizeRelease.checked;
    setPitchBendRange(parseInt(els.pbRange.value, 10));
}

function loadMpePresets() {
    const raw = localStorage.getItem(MPE_PRESET_KEY);
    return safeParseJson(raw, {});
}

function saveMpePresets(presets) {
    localStorage.setItem(MPE_PRESET_KEY, JSON.stringify(presets));
}

function safeParseJson(raw, fallback) {
    if (!raw) return fallback;
    try {
        const data = JSON.parse(raw);
        return data && typeof data === 'object' ? data : fallback;
    } catch {
        return fallback;
    }
}

function clearChildren(node) {
    while (node.firstChild) node.removeChild(node.firstChild);
}

function appendOption(select, value, label) {
    const opt = document.createElement('option');
    opt.value = value;
    opt.textContent = label;
    select.appendChild(opt);
    return opt;
}

function fillSelectFromNames(select, names, emptyLabel) {
    clearChildren(select);
    if (emptyLabel != null) appendOption(select, '', emptyLabel);
    names.forEach(name => appendOption(select, name, name));
}

function fillDatalistFromNames(datalist, names) {
    clearChildren(datalist);
    names.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        datalist.appendChild(opt);
    });
}

function refreshPresetSelect(presets, selected) {
    const names = Object.keys(presets).sort();
    fillSelectFromNames(els.presetSelect, names);
    if (selected && names.includes(selected)) els.presetSelect.value = selected;
    updatePresetDescription(els.presetSelect.value);
}

function updatePresetDescription(name) {
    els.presetDesc.innerText = PRESET_DESCRIPTIONS[name] || 'Custom preset.';
}

function refreshMpePresetSelect(presets, selected) {
    const names = Object.keys(presets).sort();
    fillSelectFromNames(els.mpePresetSelect, names);
    if (selected && names.includes(selected)) els.mpePresetSelect.value = selected;
    updateMpePresetDescription(els.mpePresetSelect.value);
}

function updateMpePresetDescription(name) {
    els.mpePresetDesc.innerText = MPE_PRESET_DESCRIPTIONS[name] || 'Custom MPE preset.';
}

function updateArpControlsUI() {
    const isOn = !!els.arpEnabled.checked;
    els.arpWheel.classList.toggle('knob-on', isOn);
    els.arpWheel.classList.toggle('knob-off', !isOn);
    els.arpWheel.innerText = isOn ? els.arpRate.value : 'Off';
}

function updateHoldButtonUI() {
    const isOn = !!els.holdNotes.checked;
    els.holdBtn.classList.toggle('active', isOn);
    els.holdBtn.classList.toggle('toggle-on', isOn);
    els.holdBtn.classList.toggle('toggle-off', !isOn);
}

function updateArpParamsToggleLabel() {
    const label = els.arpParamsToggle.querySelector('.btn-text');
    const isOpen = !els.arpParamsPanel.classList.contains('hidden');
    if (label) label.textContent = isOpen ? 'X' : 'SET';
    els.arpParamsToggle.classList.toggle('toggle-on', isOpen);
    els.arpParamsToggle.classList.toggle('toggle-off', !isOpen);
}

function updateGroupShiftUI() {
    els.groupShiftBtn.classList.toggle('toggle-on', state.groupShiftEnabled);
    els.groupShiftBtn.classList.toggle('toggle-off', !state.groupShiftEnabled);
}

function loadCustomScaleByName(name) {
    if (state.customScales[name]) {
        const entry = state.customScales[name];
        if (entry.type === 'notes') {
            els.customModeNotes.checked = true;
            els.customScaleNotes.value = formatNotesList(entry.degrees || []);
        } else {
            els.customModeCents.checked = true;
            els.customScaleCents.value = formatCentsList(entry.cents || []);
        }
        updateScaleModeUI();
    }
}

function populateMicrotonalSelect() {
    const names = Object.keys(MICROTONAL_SCALES).sort();
    fillSelectFromNames(els.microScaleSelect, names);
}

function refreshCustomScaleDatalist() {
    const names = Object.keys(state.customScales).sort();
    fillDatalistFromNames(els.customScaleNames, names);
    fillSelectFromNames(els.customScaleSaved, names, '(saved)');
}

function getScaleMode() {
    if (els.scaleModeMicro.checked) return 'microtonal';
    if (els.scaleModeCustom.checked) return 'custom';
    return 'diatonic';
}

function updateScaleModeUI() {
    const mode = getScaleMode();
    els.scaleDiatonicBox.classList.toggle('active', mode === 'diatonic');
    els.scaleMicroBox.classList.toggle('active', mode === 'microtonal');
    els.scaleCustomBox.classList.toggle('active', mode === 'custom');
    els.customScaleNotes.classList.toggle('hidden', !els.customModeNotes.checked);
    els.customScaleCents.classList.toggle('hidden', !els.customModeCents.checked);
    document.querySelectorAll('[data-scale-choice]').forEach(choice => {
        const isActive = choice.getAttribute('data-scale-choice') === mode;
        choice.classList.toggle('active', isActive);
    });
}

function getScaleDefinition() {
    const root = parseInt(els.rootNote.value, 10);
    const mode = getScaleMode();
    let def = null;
    if (mode === 'microtonal') {
        const name = els.microScaleSelect.value;
        const micro = MICROTONAL_SCALES[name];
        if (micro && Array.isArray(micro.cents) && micro.cents.length) {
            def = { root, name, mode, degrees: micro.cents.map(c => c / 100) };
        } else {
            def = { root, name: 'chromatic', mode, degrees: SCALES.chromatic.slice(0) };
        }
    } else if (mode === 'custom') {
        const name = els.customScaleName.value.trim();
        const custom = state.customScales[name];
        const useNotes = els.customModeNotes.checked;
        const degrees = useNotes
            ? (custom && custom.type === 'notes' ? custom.degrees : parseNotesList(els.customScaleNotes.value))
            : (custom && custom.type === 'cents' ? custom.cents.map(c => c / 100) : parseCentsList(els.customScaleCents.value).map(c => c / 100));
        if (degrees.length) {
            def = { root, name: name || 'custom', mode, degrees };
        } else {
            def = { root, name: 'chromatic', mode, degrees: SCALES.chromatic.slice(0) };
        }
    } else {
        const scaleType = els.scaleType.value;
        def = { root, name: scaleType, mode, degrees: SCALES[scaleType].slice(0) };
    }
    return def;
}

function getGridDegrees() {
    const def = getScaleDefinition();
    const degrees = def.degrees.slice(0);
    if (!degrees.some(d => Math.abs(d - 12) < 0.0001)) degrees.push(12);
    return { root: def.root, degrees, stepsPerOct: degrees.length, baseDegrees: def.degrees };
}

function getGridNoteAt(index, degrees, baseNote) {
    const stepsPerOct = degrees.length;
    const oct = Math.floor(index / stepsPerOct);
    const deg = degrees[index % stepsPerOct];
    return baseNote + (oct * 12) + deg;
}

function changeOctave(delta) {
    state.currentOctave = Math.max(-2, Math.min(2, state.currentOctave + delta));
    els.octVal.innerText = (state.currentOctave > 0 ? "+" : "") + state.currentOctave;
    requestDraw();
}

function setupMIDI() {
    if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess({ sysex: false }).then(access => {
            state.midi.access = access;
            const outputs = Array.from(access.outputs.values());
            const inputs = Array.from(access.inputs.values());
            
            clearChildren(els.midiOutSelect);
            outputs.forEach(o => appendOption(els.midiOutSelect, o.id, o.name || o.id || 'MIDI OUT'));
            state.midi.output = outputs[0] || null;
            els.midiOutSelect.onchange = () => {
                state.midi.output = access.outputs.get(els.midiOutSelect.value);
                setPitchBendRange(parseInt(els.pbRange.value, 10));
            };
            els.midiStatus.innerText = state.midi.output ? 'MIDI OUT READY' : 'NESSUN MIDI OUT';
            setPitchBendRange(parseInt(els.pbRange.value, 10));

            clearChildren(els.midiInSelect);
            appendOption(els.midiInSelect, '', 'Scegli Input...');
            inputs.forEach(i => appendOption(els.midiInSelect, i.id, i.name || i.id || 'MIDI IN'));
            if (inputs[0]) {
                els.midiInSelect.value = inputs[0].id;
                state.midi.input = inputs[0];
                state.midi.input.onmidimessage = handleExternalMIDI;
                els.midiStatus.innerText = 'MIDI IN READY';
            }
            els.midiInSelect.onchange = () => {
                if (state.midi.input) state.midi.input.onmidimessage = null;
                state.midi.input = access.inputs.get(els.midiInSelect.value);
                if (state.midi.input) state.midi.input.onmidimessage = handleExternalMIDI;
                els.midiStatus.innerText = state.midi.input ? 'MIDI IN READY' : 'NESSUN MIDI IN';
            };
        }).catch(() => {
            els.midiStatus.innerText = 'MIDI NON DISPONIBILE';
        });
    }
}

// GESTIONE NOTE DA CONTROLLER ESTERNO
function handleExternalMIDI(message) {
    const [status, data1, data2] = message.data;
    if (status >= 0xF8) {
        handleClockMessage(status);
        if (els.midiThru.checked && state.midi.output) state.midi.output.send(message.data);
        return;
    }
    requestDraw();
    const note = data1;
    const velocity = data2;
    const type = status & 0xf0;
    const srcChan = status & 0x0f;
    const microtonalize = els.scaleModeMicro.checked && els.microtonalizeIn.checked;
    if (type === 0x90 && velocity > 0 && isLocalNoteOn(note)) {
        return;
    }
    const thruOnly = els.midiThru.checked && !microtonalize;
    if (thruOnly) {
        if (state.midi.output) state.midi.output.send(message.data);
    }
    if (type === 0x90 && velocity > 0) {
        if (microtonalize) {
            const noteFloat = mapMidiNoteToScale(note);
            const voice = makeVoiceFromNote(noteFloat);
            const chan = state.mpeChannels.shift();
            if (!chan) {
                els.midiStatus.innerText = 'MPE CHANNELS FULL';
            }
            if (chan && state.midi.output) {
                const pb = clampPb(8192 + voice.basePb);
                state.midi.output.send([0xB0 + chan - 1, 74, 0]);
                state.midi.output.send([0xE0 + chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
                state.midi.output.send([0x90 + chan - 1, voice.note, velocity]);
            }
            const list = state.physicalNotes.get(voice.note) || [];
            list.push({ chan: chan || 0, note: voice.note, basePb: voice.basePb, velocity, grabbed: false, srcChan, srcNote: note, lastPb: 8192, lastSlide: 0, lastPress: 0, onTs: Date.now() });
            state.physicalNotes.set(voice.note, list);
            state.externalNoteMap.set(`${srcChan}:${note}`, { keyNote: voice.note, chan: chan || 0 });
        } else {
            const chan = thruOnly ? 0 : state.mpeChannels.shift();
            if (!thruOnly && !chan) {
                els.midiStatus.innerText = 'MPE CHANNELS FULL';
            }
            if (!thruOnly && chan && state.midi.output) {
                state.midi.output.send([0x90 + chan - 1, note, velocity]);
            }
            const list = state.physicalNotes.get(note) || [];
            list.push({ chan: chan || 0, velocity, grabbed: false, srcChan, lastPb: 8192, lastSlide: 0, lastPress: 0, onTs: Date.now() });
            state.physicalNotes.set(note, list);
        }
    } else if (type === 0x80 || (type === 0x90 && velocity === 0)) {
        if (microtonalize) {
            const key = state.externalNoteMap.get(`${srcChan}:${note}`);
            if (key) {
                const list = state.physicalNotes.get(key.keyNote);
                if (list && list.length) {
                    const idx = list.findIndex(d => d.srcChan === srcChan && d.srcNote === note);
                    const data = idx >= 0 ? list.splice(idx, 1)[0] : list.shift();
                    if (data && data.chan) {
                        if (state.midi.output) state.midi.output.send([0x80 + data.chan - 1, data.note || key.keyNote, 0]);
                        state.mpeChannels.push(data.chan);
                        state.mpeChannels.sort((a,b)=>a-b);
                    }
                    if (!list.length) state.physicalNotes.delete(key.keyNote);
                }
                state.externalNoteMap.delete(`${srcChan}:${note}`);
            }
        } else {
            const list = state.physicalNotes.get(note);
            if (list && list.length) {
                const idx = list.findIndex(d => d.srcChan === srcChan);
                const data = idx >= 0 ? list.splice(idx, 1)[0] : list.shift();
                if (data) {
                    if (data.chan) {
                        if (!thruOnly && state.midi.output) state.midi.output.send([0x80 + data.chan - 1, note, 0]);
                        state.mpeChannels.push(data.chan);
                        state.mpeChannels.sort((a,b)=>a-b);
                    }
                }
                if (!list.length) state.physicalNotes.delete(note);
            }
        }
    } else if (type === 0xE0 || type === 0xD0 || type === 0xB0) {
        const list = [];
        state.physicalNotes.forEach(arr => arr.forEach(v => { if (v.srcChan === srcChan) list.push(v); }));
        if (!list.length) return;
        if (type === 0xE0) {
            const pb = (message.data[2] << 7) | message.data[1];
            list.forEach(v => {
                v.lastPb = pb;
                if (!thruOnly && v.chan && !v.grabbed && state.midi.output) {
                    state.midi.output.send([0xE0 + v.chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
                }
            });
        } else if (type === 0xD0) {
            const press = message.data[1];
            list.forEach(v => {
                v.lastPress = press;
                if (!thruOnly && v.chan && !v.grabbed && state.midi.output) {
                    state.midi.output.send([0xD0 + v.chan - 1, press]);
                }
            });
        } else if (type === 0xB0 && message.data[1] === 74) {
            const slide = message.data[2];
            list.forEach(v => {
                v.lastSlide = slide;
                if (!thruOnly && v.chan && !v.grabbed && state.midi.output) {
                    state.midi.output.send([0xB0 + v.chan - 1, 74, slide]);
                }
            });
        }
    }
}

function getCurveExponent() {
    const type = els.curveType.value;
    if (type === 'soft') return 0.6;
    if (type === 'hard') return 1.8;
    return 1.0;
}

function applyCurve(value) {
    const v = Math.max(0, Math.min(1, value));
    const exp = getCurveExponent();
    return Math.pow(v, exp);
}

function applySmoothing(touch, m) {
    const smoothAmt = parseInt(els.smoothAmt.value, 10) / 100;
    if (!smoothAmt) return m;
    const mix = 1 - smoothAmt;
    touch.smoothPb = touch.smoothPb == null ? m.pbValue : touch.smoothPb + (m.pbValue - touch.smoothPb) * mix;
    touch.smoothSlide = touch.smoothSlide == null ? m.slide : touch.smoothSlide + (m.slide - touch.smoothSlide) * mix;
    touch.smoothPress = touch.smoothPress == null ? m.press : touch.smoothPress + (m.press - touch.smoothPress) * mix;
    return {
        ...m,
        pbValue: Math.round(touch.smoothPb),
        slide: Math.round(touch.smoothSlide),
        press: Math.round(touch.smoothPress)
    };
}

function sendMidi(data) {
    if (!state.midi.output) return;
    state.midi.output.send(data);
}




function getRateFactor(rate) {
    if (rate === '1/4') return 1;
    if (rate === '1/8') return 0.5;
    if (rate === '1/8T') return 1 / 3;
    if (rate === '1/16') return 0.25;
    if (rate === '1/16T') return 1 / 6;
    if (rate === '1/32') return 0.125;
    return 0.25;
}

function updateArpTiming() {
    const factor = getRateFactor(state.arp.rate);
    state.arp.ticksPerStep = Math.max(1, Math.round(24 * factor));
}

function getStepMs() {
    const factor = getRateFactor(state.arp.rate);
    return (60 / Math.max(40, state.arp.bpm)) * 1000 * factor;
}

function stopAllArpNotes() {
    if (!state.midi.output) return;
    state.arp.active.forEach(entry => {
        if (entry.offTimer) {
            clearTimeout(entry.offTimer);
            entry.offTimer = null;
        }
        state.midi.output.send([0x80 + entry.chan - 1, entry.note, 0]);
        state.mpeChannels.push(entry.chan);
    });
    state.arp.active = [];
    state.mpeChannels.sort((a,b)=>a-b);
}

function stopArpActiveNote(note) {
    if (!state.midi.output || note == null) return;
    const remaining = [];
    state.arp.active.forEach(entry => {
        if (entry.note === note) {
            if (entry.offTimer) {
                clearTimeout(entry.offTimer);
                entry.offTimer = null;
            }
            state.midi.output.send([0x80 + entry.chan - 1, entry.note, 0]);
            state.mpeChannels.push(entry.chan);
        } else {
            remaining.push(entry);
        }
    });
    state.arp.active = remaining;
    state.mpeChannels.sort((a,b)=>a-b);
}

function stopArpActiveNotes(noteObjs) {
    if (!noteObjs || !noteObjs.length) return;
    noteObjs.forEach(n => stopArpActiveNote(n.note));
}

function arpNoteOn(noteObj, stepMs) {
    if (!state.midi.output) return;
    const chan = state.mpeChannels.shift();
    if (!chan) {
        els.midiStatus.innerText = 'MPE CHANNELS FULL';
        return;
    }
    const m = noteObj.lastM || { pbValue: 8192, slide: 0, press: 90 };
    const vel = Math.max(0, Math.min(127, Math.round(m.press ?? 90)));
    if (vel <= 0) {
        state.mpeChannels.push(chan);
        state.mpeChannels.sort((a,b)=>a-b);
        return;
    }
    const pb = getVoicePb(m, noteObj);
    sendMidi([0xB0 + chan - 1, 74, m.slide]);
    sendMidi([0xE0 + chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
    sendMidi([0xD0 + chan - 1, m.press]);
    sendMidi([0x90 + chan - 1, noteObj.note, vel]);
    markLocalNoteOn(noteObj.note);
    const entry = { chan, note: noteObj.note, color: noteObj.color, offTimer: null };
    state.arp.active.push(entry);
    const gateMs = Math.max(10, stepMs * state.arp.gate);
    entry.offTimer = setTimeout(() => {
        if (!state.arp.active.includes(entry)) return;
        sendMidi([0x80 + entry.chan - 1, entry.note, 0]);
        state.mpeChannels.push(entry.chan);
        state.mpeChannels.sort((a,b)=>a-b);
        state.arp.active = state.arp.active.filter(e => e !== entry);
    }, gateMs);
}

function arpStep(stepMsOverride) {
    if (!state.arp.enabled || !state.arp.notes.length) return;
    const stepMs = stepMsOverride || getStepMs();
    const noteObj = state.arp.notes[state.arp.stepIndex % state.arp.notes.length];
    state.arp.stepIndex++;
    arpNoteOn(noteObj, stepMs);
    requestDraw();
}

function restartInternalArp() {
    if (state.arp.timer) clearInterval(state.arp.timer);
    if (!state.arp.enabled || state.arp.sync !== 'internal') return;
    const stepMs = getStepMs();
    state.arp.running = true;
    state.arp.timer = setInterval(() => arpStep(stepMs), stepMs);
}

function stopInternalArp() {
    if (state.arp.timer) clearInterval(state.arp.timer);
    state.arp.timer = null;
}

function syncArpFromUI() {
    const wasEnabled = state.arp.enabled;
    state.arp.enabled = els.arpEnabled.checked;
    state.arp.rate = els.arpRate.value;
    state.arp.gate = parseInt(els.arpGate.value, 10) / 100;
    state.arp.sync = els.arpSync.value;
    state.arp.bpm = parseInt(els.arpBpm.value, 10) || 120;
    state.arp.latch = els.arpLatch.checked;
    updateArpTiming();
    updateArpControlsUI();
    if (!state.arp.enabled) {
        state.arp.running = false;
        stopInternalArp();
        stopAllArpNotes();
        state.arp.notes = [];
        state.arpHoldTouches = [];
        return;
    }
    if (!wasEnabled && els.holdNotes.checked && state.heldVoices.length) {
        convertHeldToArp();
    }
    if (state.arp.sync === 'internal') {
        restartInternalArp();
    } else {
        stopInternalArp();
    }
}


function handleClockMessage(status) {
    if (!state.arp.enabled || state.arp.sync !== 'midi') return;
    if (status === 0xFA) {
        state.arp.running = true;
        state.arp.stepIndex = 0;
        state.arp.clockTicks = 0;
        state.arp.lastClockTime = 0;
        stopAllArpNotes();
        return;
    }
    if (status === 0xFC) {
        state.arp.running = false;
        state.arp.lastClockTime = 0;
        stopAllArpNotes();
        return;
    }
    if (status === 0xFB) {
        state.arp.running = true;
        return;
    }
    if (status === 0xF8) {
        const now = performance.now();
        if (state.arp.lastClockTime) state.arp.tickMs = now - state.arp.lastClockTime;
        state.arp.lastClockTime = now;
        if (!state.arp.running) return;
        state.arp.clockTicks++;
        if (state.arp.clockTicks % state.arp.ticksPerStep === 0) {
            const stepMs = state.arp.tickMs ? state.arp.tickMs * state.arp.ticksPerStep : getStepMs();
            arpStep(stepMs);
        }
    }
}

function removeArpNotes(noteObjs) {
    if (!noteObjs || !noteObjs.length) return;
    state.arp.notes = state.arp.notes.filter(n => !noteObjs.includes(n));
    if (!state.arp.notes.length) state.arpHoldTouches = [];
}

function getMPEData(e, voice = null, forceSnap = false) {
    const numOct = parseInt(els.visibleOctaves.value, 10);
    let round = parseInt(els.roundRate.value, 10) / 100;
    let deadCenter = els.deadCenter.checked;
    const dcForce = parseInt(els.deadCenterForce.value, 10) / 100;
    if (els.quantizeRelease.checked && !forceSnap && voice) {
        round = 0;
        deadCenter = false;
    }
    const grid = getGridDegrees();
    const baseMIDI = 48 + (state.currentOctave * 12) + grid.root;
    const totalNotes = numOct * grid.stepsPerOct;
    const stepExact = ((e.clientX - state.canvasRect.left) / state.canvasRect.width) * totalNotes;
    const centerExact = stepExact - 0.5;
    const stepIdx = Math.max(0, Math.min(totalNotes - 1, Math.floor(centerExact)));
    const stepFrac = centerExact - stepIdx;
    const noteA = getGridNoteAt(stepIdx, grid.degrees, baseMIDI);
    const noteB = getGridNoteAt(Math.min(stepIdx + 1, totalNotes - 1), grid.degrees, baseMIDI);
    const currentExact = noteA + ((noteB - noteA) * stepFrac);
    
    let finalExact = currentExact;
    let detune = 0;
    if (voice) {
        const nearestNote = noteA;
        const distanceToNote = Math.abs(currentExact - nearestNote);
        const dcZone = round * (0.2 + (dcForce * 0.8));
        if (deadCenter && distanceToNote < dcZone) {
            const force = 1 - (distanceToNote / Math.max(0.0001, dcZone));
            finalExact = currentExact + (nearestNote - currentExact) * force;
        } else if (distanceToNote < round) {
            const force = 1 - (distanceToNote / round);
            finalExact = currentExact + (nearestNote - currentExact) * force;
        }
        detune = finalExact - voice.initialExact;
        voice.vibratoSpeed = Math.abs(e.clientX - voice.lastX) * 2.8;
        voice.lastX = e.clientX;
    }
    const pbRange = parseInt(els.pbRange.value, 10) || 12;
    let pbValue = Math.floor(8192 + (detune * (8192 / pbRange)));
    pbValue = Math.max(0, Math.min(16383, pbValue));
    const top = state.canvasRect.top;
    const bottom = getCanvasBottomY();
    const yRange = Math.max(1, bottom - top);
    const yClamped = Math.max(top, Math.min(e.clientY, bottom));
    const yNorm = Math.max(0, Math.min(1, 1 - ((yClamped - top) / yRange)));
    const dz = parseInt(els.yDeadzone.value, 10) / 100;
    let slideNorm = yNorm;
    if (dz > 0) {
        slideNorm = slideNorm < dz ? 0 : (slideNorm - dz) / (1 - dz);
    }
    slideNorm = applyCurve(slideNorm);
    const slide = Math.floor(slideNorm * 127);
    const useYForVelocity = els.linkPressToY.checked && els.linkYToVelocity.checked;
    let pressNorm = useYForVelocity ? slideNorm : Math.min(((e.width + e.height) / 75), 1.0);
    pressNorm = applyCurve(pressNorm);
    const press = Math.floor(pressNorm * 127);
    return { pbValue, slide, press, x: e.clientX, y: e.clientY, exact: finalExact };
}

function clampPb(value) {
    return Math.max(0, Math.min(16383, value));
}

function markLocalNoteOn(note) {
    state.localNoteOnTimes.set(note, Date.now());
}

function isLocalNoteOn(note) {
    const ts = state.localNoteOnTimes.get(note);
    if (!ts) return false;
    if (Date.now() - ts > LOCAL_SUPPRESS_MS) {
        state.localNoteOnTimes.delete(note);
        return false;
    }
    return true;
}

function makeVoiceFromNote(noteFloat) {
    const pbRange = parseInt(els.pbRange.value, 10) || 12;
    const midiNote = Math.max(0, Math.min(127, Math.round(noteFloat)));
    const detune = noteFloat - midiNote;
    const basePb = Math.round(detune * (8192 / pbRange));
    return { note: midiNote, basePb };
}

function getVoicePb(m, voice) {
    const base = voice.basePb || 0;
    return clampPb(m.pbValue + base);
}

function getVoiceNoteFloat(voice) {
    const pbRange = parseInt(els.pbRange.value, 10) || 12;
    const basePb = voice.basePb || 0;
    return (voice.note || 0) + (basePb * (pbRange / 8192));
}

function getNearestScaleNote(exact) {
    const root = parseInt(els.rootNote.value, 10);
    const def = getScaleDefinition();
    const scaleKey = `${def.mode}:${def.name}`;
    if (!state.scaleNotes.notes.length || state.scaleNotes.root !== root || state.scaleNotes.scale !== scaleKey) {
        updateScaleNotes();
    }
    if (!state.scaleNotes.notes.length) return exact;
    return state.scaleNotes.notes.reduce((prev, curr) => Math.abs(curr - exact) < Math.abs(prev - exact) ? curr : prev);
}

function snapHoldVoicesToScale(t) {
    if (!t || !t.voices || !t.voices.length) return;
    const exact = t.lastM?.exact ?? t.initialExact ?? 0;
    const rootNote = getNearestScaleNote(exact);
    const chordNotes = computeChordNotes(rootNote);
    const m = t.lastM ? { ...t.lastM, exact: rootNote } : { pbValue: 8192, slide: 0, press: 90, exact: rootNote, x: 0, y: 0 };
    const pbRange = parseInt(els.pbRange.value, 10) || 12;
    m.pbValue = 8192;
    t.lastM = m;
    t.initialExact = rootNote;
    for (let i = 0; i < t.voices.length; i++) {
        const v = t.voices[i];
        const noteFloat = chordNotes[i] ?? rootNote;
        const basePb = Math.round((noteFloat - (v.note || 0)) * (8192 / pbRange));
        v.basePb = Math.max(-8192, Math.min(8191, basePb));
        const pb = getVoicePb(m, v);
        if (v.chan) {
            sendMidi([0xB0 + v.chan - 1, 74, m.slide]);
            sendMidi([0xE0 + v.chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
            sendMidi([0xD0 + v.chan - 1, m.press]);
        }
    }
}

function drawGridBaseToContext(gctx, width, height, grid, numOct, noteW, baseMIDI) {
    const mode = getScaleMode();
    gctx.clearRect(0, 0, width, height);
    for (let i = 0; i < (numOct * grid.stepsPerOct); i++) {
        const n = getGridNoteAt(i, grid.degrees, baseMIDI);
        const x = i * noteW;
        const isOctStart = (i % grid.stepsPerOct === 0);
        const nRound = Math.round(n);
        const isRoot = (nRound % 12 === grid.root);
        gctx.fillStyle = isRoot ? 'rgba(255, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.15)';
        gctx.fillRect(x, 0, noteW, height);
        gctx.strokeStyle = isOctStart ? '#ff3333' : (isRoot ? '#ff0000' : '#666');
        gctx.lineWidth = isOctStart ? 3 : (isRoot ? 3 : 1);
        gctx.beginPath(); gctx.moveTo(x, 0); gctx.lineTo(x, height); gctx.stroke();
        const degree = grid.degrees[i % grid.stepsPerOct];
        if (!(degree === 12 && i < (numOct * grid.stepsPerOct - 1))) {
            gctx.font = `bold ${Math.max(13, Math.floor(noteW * 0.5))}px ${CANVAS_FONT_FAMILY}`; gctx.textAlign = 'center';
            gctx.fillStyle = isRoot ? '#ff4444' : '#ffffff';
            gctx.strokeStyle = '#000'; gctx.lineWidth = 4;
            const noteY = Math.floor(height * 0.5);
            gctx.strokeText(NOTE_NAMES[nRound % 12], x + noteW/2, noteY);
            gctx.fillText(NOTE_NAMES[nRound % 12], x + noteW/2, noteY);
            if (mode !== 'diatonic' && noteW >= 48) {
                const cents = Math.round((degree % 12) * 100);
                gctx.font = `bold 9px ${CANVAS_FONT_FAMILY}`; gctx.textAlign = 'center';
                gctx.fillStyle = '#ffaa00';
                gctx.fillText(`${cents}c`, x + noteW/2, noteY + 16);
            }
        }
    }
}

function updateGridCache() {
    const numOct = parseInt(els.visibleOctaves.value, 10);
    const grid = getGridDegrees();
    const baseMIDI = 48 + (state.currentOctave * 12) + grid.root;
    const totalNotes = numOct * grid.stepsPerOct;
    const width = Math.floor(state.canvasRect.width);
    const height = Math.floor(state.canvasRect.height);
    const noteW = width / totalNotes;
    const key = [
        width, height, numOct, state.currentOctave, grid.root, grid.degrees.join(','),
        getScaleMode()
    ].join('|');
    const cols = [];
    for (let i = 0; i < totalNotes; i++) {
        const n = getGridNoteAt(i, grid.degrees, baseMIDI);
        cols.push({ note: n, x: (i * noteW) + (noteW / 2) });
    }
    const needBg = !state.gridCache || state.gridCache.key !== key;
    let bgCanvas = state.gridCache ? state.gridCache.bgCanvas : null;
    if (needBg) {
        if (!bgCanvas) bgCanvas = document.createElement('canvas');
        bgCanvas.width = width;
        bgCanvas.height = height;
        const gctx = bgCanvas.getContext('2d');
        drawGridBaseToContext(gctx, width, height, grid, numOct, noteW, baseMIDI);
    }
    state.gridCache = { cols, noteW, baseMIDI, grid, numOct, totalNotes, key, bgCanvas };
}

function getNearestNoteX(noteFloat) {
    if (!state.gridCache || !state.gridCache.cols.length) return null;
    let best = null;
    let bestDist = Infinity;
    for (let i = 0; i < state.gridCache.cols.length; i++) {
        const col = state.gridCache.cols[i];
        const dist = Math.abs(col.note - noteFloat);
        if (dist < bestDist) {
            bestDist = dist;
            best = col.x;
        }
    }
    return best;
}

function drawNoteBubble(x, y, radius, color, label) {
    ctx.shadowBlur = 20;
    ctx.shadowColor = color;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    if (label) {
        ctx.fillStyle = "#fff";
        ctx.font = `bold 12px ${CANVAS_FONT_FAMILY}`;
        ctx.textAlign = 'center';
        ctx.fillText(label, x, y - radius - 16);
    }
}

function getGroupDragKey(type, id) {
    return `${type}:${id}`;
}

function getActiveGroupTouches(key) {
    const list = [];
    state.activeTouches.forEach(t => {
        if (t.isGroupDrag && t.groupDragKey === key) list.push(t);
    });
    return list;
}

function startHoldGroupDrag(groupId) {
    if (!groupId) return null;
    const key = getGroupDragKey('hold', groupId);
    if (state.groupDragStates.has(key)) return state.groupDragStates.get(key);
    const voices = [];
    state.heldVoices.forEach(v => { if (v.group === groupId) voices.push(v); });
    state.activeTouches.forEach(t => {
        if (t.isHoldGrab && t.holdGroup === groupId && t.voices) {
            t.voices.forEach(v => voices.push(v));
        }
    });
    const pbRange = parseInt(els.pbRange.value, 10) || 12;
    const origBasePb = new Map();
    let sumExact = 0;
    voices.forEach(v => {
        origBasePb.set(v, v.basePb || 0);
        const noteFloat = (v.note || 0) + ((v.basePb || 0) * (pbRange / 8192));
        sumExact += noteFloat;
    });
    const anchorExact = voices.length ? sumExact / voices.length : 0;
    const dragState = { key, type: 'hold', groupId, voices, origBasePb, anchorExact, lastX: null };
    state.groupDragStates.set(key, dragState);
    return dragState;
}

function startArpGroupDrag(holdIdx) {
    const key = getGroupDragKey('arp', holdIdx);
    if (state.groupDragStates.has(key)) return state.groupDragStates.get(key);
    const hold = state.arpHoldTouches[holdIdx];
    if (!hold || !hold.noteObjs) return null;
    const noteObjs = hold.noteObjs.slice(0);
    let sumExact = 0;
    noteObjs.forEach(n => { sumExact += (n.noteFloat ?? n.note ?? 0); });
    const anchorExact = noteObjs.length ? sumExact / noteObjs.length : 0;
    const origNoteFloat = new Map();
    noteObjs.forEach(n => origNoteFloat.set(n, n.noteFloat ?? n.note ?? 0));
    const dragState = { key, type: 'arp', holdIdx, noteObjs, origNoteFloat, anchorExact, lastX: null };
    state.groupDragStates.set(key, dragState);
    return dragState;
}

function handleGroupDrag(t) {
    const dragState = state.groupDragStates.get(t.groupDragKey);
    if (!dragState) return;
    const touches = getActiveGroupTouches(dragState.key);
    if (!touches.length) return;
    const avgX = touches.reduce((s, item) => s + (item.lastX ?? 0), 0) / touches.length;
    const avgY = touches.reduce((s, item) => s + (item.lastM?.y ?? 0), 0) / touches.length;
    const fakeEvent = { clientX: avgX, clientY: avgY, width: 0, height: 0 };
    const voiceRef = { initialExact: dragState.anchorExact, lastX: dragState.lastX ?? avgX, vibratoSpeed: 0 };
    const m = getMPEData(fakeEvent, voiceRef);
    dragState.lastX = avgX;
    const pbRange = parseInt(els.pbRange.value, 10) || 12;
    const deltaExact = m.exact - dragState.anchorExact;
    const pbDelta = Math.round(deltaExact * (8192 / pbRange));
    if (dragState.type === 'hold') {
        dragState.voices.forEach(v => {
            const basePbOrig = dragState.origBasePb.get(v) || 0;
            const newBasePb = basePbOrig + pbDelta;
            v.basePb = newBasePb;
            v.lastM = { ...m, x: avgX, y: avgY, exact: (v.note || 0) + (newBasePb * (pbRange / 8192)) };
            const pb = clampPb(8192 + basePbOrig + pbDelta);
            if (v.chan) {
                sendMidi([0xE0 + v.chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
                sendMidi([0xB0 + v.chan - 1, 74, m.slide]);
                sendMidi([0xD0 + v.chan - 1, m.press]);
            }
        });
    } else if (dragState.type === 'arp') {
        dragState.noteObjs.forEach(n => {
            const base = dragState.origNoteFloat.get(n) || 0;
            const noteFloat = base + deltaExact;
            const voice = makeVoiceFromNote(noteFloat);
            n.noteFloat = noteFloat;
            n.note = voice.note;
            n.basePb = voice.basePb;
            n.lastM = { ...m, x: avgX, y: avgY, exact: noteFloat };
        });
    }
}

function cleanupGroupDrag(key) {
    if (!key) return;
    const stillActive = Array.from(state.activeTouches.values()).some(t => t.isGroupDrag && t.groupDragKey === key);
    if (!stillActive) state.groupDragStates.delete(key);
}

function startGroupShiftDrag(e) {
    const holdHit = findHeldVoiceAt(e.clientX, e.clientY);
    if (holdHit) {
        const hv = state.heldVoices[holdHit.idx];
        const groupId = hv.group || 0;
        if (!groupId) return false;
        const key = getGroupDragKey('hold', groupId);
        startHoldGroupDrag(groupId);
        const tmpVoice = { initialExact: hv.rootNote ?? hv.note, lastX: e.clientX, vibratoSpeed: 0 };
        const m = getMPEData(e, tmpVoice);
        state.activeTouches.set(e.pointerId, {
            voices: [],
            isGroupDrag: true,
            groupDragKey: key,
            lastX: e.clientX,
            lastM: m,
            color: hv.color,
            phase: hv.phase || 0,
            initialExact: hv.rootNote ?? hv.note
        });
        return true;
    }
    const arpNoteHit = findArpHoldNoteAt(e.clientX, e.clientY);
    const arpHoldHit = arpNoteHit ? null : findArpHoldAt(e.clientX, e.clientY);
    const holdIdx = arpNoteHit ? arpNoteHit.holdIdx : (arpHoldHit ? arpHoldHit.idx : null);
    if (holdIdx != null) {
        const hold = state.arpHoldTouches[holdIdx];
        if (!hold) return false;
        const key = getGroupDragKey('arp', holdIdx);
        startArpGroupDrag(holdIdx);
        const baseExact = hold.lastM?.exact ?? 0;
        const tmpVoice = { initialExact: baseExact, lastX: e.clientX, vibratoSpeed: 0 };
        const m = getMPEData(e, tmpVoice);
        state.activeTouches.set(e.pointerId, {
            voices: [],
            isGroupDrag: true,
            groupDragKey: key,
            lastX: e.clientX,
            lastM: m,
            color: hold.color || '#ffaa00',
            phase: hold.phase || 0,
            initialExact: baseExact
        });
        return true;
    }
    return false;
}

function tryStartTwoFingerGroupDrag(e) {
    if (Array.from(state.activeTouches.values()).some(t => t.isGroupDrag)) return true;
    if (!state.activeTouches.size) return false;
    let holdEntry = null;
    let arpEntry = null;
    state.activeTouches.forEach((t, id) => {
        if (!holdEntry && t.isHoldGrab && t.holdGroup) holdEntry = { id, t };
        if (!arpEntry && t.isArpHoldGrab && Number.isInteger(t.holdIdx)) arpEntry = { id, t };
    });
    if (holdEntry) {
        const groupId = holdEntry.t.holdGroup;
        const key = getGroupDragKey('hold', groupId);
        startHoldGroupDrag(groupId);
        holdEntry.t.isGroupDrag = true;
        holdEntry.t.groupDragKey = key;
        state.activeTouches.set(e.pointerId, {
            voices: [],
            isGroupDrag: true,
            groupDragKey: key,
            lastX: e.clientX,
            lastM: { x: e.clientX, y: e.clientY, press: 0, slide: 0, pbValue: 8192, exact: holdEntry.t.initialExact ?? 0 },
            color: holdEntry.t.color,
            phase: holdEntry.t.phase || 0
        });
        return true;
    }
    if (arpEntry) {
        const key = getGroupDragKey('arp', arpEntry.t.holdIdx);
        startArpGroupDrag(arpEntry.t.holdIdx);
        arpEntry.t.isGroupDrag = true;
        arpEntry.t.groupDragKey = key;
        state.activeTouches.set(e.pointerId, {
            voices: [],
            isGroupDrag: true,
            groupDragKey: key,
            lastX: e.clientX,
            lastM: { x: e.clientX, y: e.clientY, press: 0, slide: 0, pbValue: 8192, exact: arpEntry.t.initialExact ?? 0 },
            color: arpEntry.t.color,
            phase: arpEntry.t.phase || 0
        });
        return true;
    }
    return false;
}

const DROP_DURATION_MS = 1000;
const DOUBLE_TAP_MS = 280;
const DOUBLE_TAP_PX = 24;
const heldTapState = new Map();

function isDoubleTap(obj, x, y) {
    if (!obj) return false;
    const now = performance.now();
    const last = obj._tapTime || 0;
    const dx = (obj._tapX ?? x) - x;
    const dy = (obj._tapY ?? y) - y;
    obj._tapTime = now;
    obj._tapX = x;
    obj._tapY = y;
    return (now - last) <= DOUBLE_TAP_MS && (dx * dx + dy * dy) <= (DOUBLE_TAP_PX * DOUBLE_TAP_PX);
}

function isDoubleTapKey(key, x, y) {
    if (!key) return false;
    const now = performance.now();
    const last = heldTapState.get(key) || { t: 0, x, y };
    const dx = last.x - x;
    const dy = last.y - y;
    heldTapState.set(key, { t: now, x, y });
    return (now - last.t) <= DOUBLE_TAP_MS && (dx * dx + dy * dy) <= (DOUBLE_TAP_PX * DOUBLE_TAP_PX);
}

function getCanvasBottomY() {
    return state.canvasRect.top + Math.max(1, state.canvasRect.height);
}

function getSlideFromY(y) {
    const top = state.canvasRect.top;
    const bottom = getCanvasBottomY();
    const yRange = Math.max(1, bottom - top);
    const yClamped = Math.max(top, Math.min(y, bottom));
    let yNorm = Math.max(0, Math.min(1, 1 - ((yClamped - top) / yRange)));
    const dz = parseInt(els.yDeadzone.value, 10) / 100;
    if (dz > 0) {
        yNorm = yNorm < dz ? 0 : (yNorm - dz) / (1 - dz);
    }
    yNorm = applyCurve(yNorm);
    return Math.floor(yNorm * 127);
}

function startHoldDrop(voice) {
    if (!voice || voice.dropActive) return;
    const m = voice.lastM || { x: 0, y: getCanvasBottomY(), press: 90, slide: 0 };
    voice.dropActive = true;
    const startY = m.y;
    const endY = getCanvasBottomY();
    const startPress = Number.isFinite(m.press) ? m.press : 90;
    const start = performance.now();

    function tick(now) {
        const t = Math.min(1, (now - start) / DROP_DURATION_MS);
        const y = startY + (endY - startY) * t;
        const press = Math.max(0, Math.round(startPress * (1 - t)));
        const slide = getSlideFromY(y);
        m.y = y;
        m.press = press;
        m.slide = slide;
        voice.lastM = m;
        if (voice.chan) {
            sendMidi([0xB0 + voice.chan - 1, 74, slide]);
            sendMidi([0xD0 + voice.chan - 1, press]);
        }
        if (t < 1) {
            voice.dropRaf = requestAnimationFrame(tick);
        } else {
            if (voice.chan) {
                sendMidi([0x80 + voice.chan - 1, voice.note, 0]);
                state.mpeChannels.push(voice.chan);
                state.mpeChannels.sort((a,b)=>a-b);
            }
            state.heldVoices = state.heldVoices.filter(v => v !== voice);
            voice.dropActive = false;
        }
    }
    voice.dropRaf = requestAnimationFrame(tick);
}

function startArpHoldDrop(hold, noteObj) {
    if (!hold || !noteObj || noteObj.dropActive) return;
    const baseM = noteObj.lastM || hold.lastM || { x: 0, y: getCanvasBottomY(), press: 90, slide: 0 };
    noteObj.dropActive = true;
    const startY = baseM.y;
    const endY = getCanvasBottomY();
    const startPress = Number.isFinite(baseM.press) ? baseM.press : 90;
    const start = performance.now();

    function tick(now) {
        const t = Math.min(1, (now - start) / DROP_DURATION_MS);
        const y = startY + (endY - startY) * t;
        const press = Math.max(0, Math.round(startPress * (1 - t)));
        const slide = getSlideFromY(y);
        baseM.y = y;
        baseM.press = press;
        baseM.slide = slide;
        noteObj.lastM = baseM;
        if (t < 1) {
            noteObj.dropRaf = requestAnimationFrame(tick);
        } else {
            stopArpActiveNote(noteObj.note);
            removeArpNotes([noteObj]);
            if (hold.noteObjs) {
                hold.noteObjs = hold.noteObjs.filter(n => n !== noteObj);
                if (!hold.noteObjs.length) {
                    state.arpHoldTouches = state.arpHoldTouches.filter(h => h !== hold);
                }
            }
            noteObj.dropActive = false;
        }
    }
    noteObj.dropRaf = requestAnimationFrame(tick);
}

function collectActiveChannels() {
    const set = new Set();
    state.activeTouches.forEach(t => {
        t.voices.forEach(v => { if (v.chan) set.add(v.chan); });
    });
    state.heldVoices.forEach(v => { if (v.chan) set.add(v.chan); });
    state.physicalNotes.forEach(arr => arr.forEach(v => { if (v.chan) set.add(v.chan); }));
    state.arp.active.forEach(v => { if (v.chan) set.add(v.chan); });
    return Array.from(set);
}

function collectFadeTargets() {
    const targets = new Map();
    function push(ch, slide, press) {
        if (!ch) return;
        const cur = targets.get(ch) || { slide: 0, press: 0 };
        const s = Number.isFinite(slide) ? slide : 0;
        const p = Number.isFinite(press) ? press : 0;
        targets.set(ch, { slide: Math.max(cur.slide, s), press: Math.max(cur.press, p) });
    }
    state.activeTouches.forEach(t => {
        t.voices.forEach(v => push(v.chan, t.lastM?.slide, t.lastM?.press));
    });
    state.heldVoices.forEach(v => push(v.chan, v.lastM?.slide, v.lastM?.press));
    state.physicalNotes.forEach(arr => arr.forEach(v => push(v.chan, v.lastSlide, v.lastPress)));
    state.arp.active.forEach(v => push(v.chan, 0, 80));
    return targets;
}

function collectActiveNotes() {
    const map = new Map();
    function addNote(chan, note, press) {
        if (!chan || note == null) return;
        const key = `${chan}:${note}`;
        const vel = Math.max(1, Math.min(127, Math.round(press || 80)));
        map.set(key, { chan, note, vel });
    }
    state.activeTouches.forEach(t => {
        t.voices.forEach(v => addNote(v.chan, v.note, t.lastM?.press));
    });
    state.heldVoices.forEach(v => addNote(v.chan, v.note, v.lastM?.press));
    state.physicalNotes.forEach(arr => arr.forEach(v => addNote(v.chan, v.note, v.lastPress)));
    state.arp.active.forEach(v => addNote(v.chan, v.note, 80));
    return Array.from(map.values());
}

function runEchoTail() {
    return 0;
}

function fadeOutAll() {
    if (!state.midi.output) return;
    if (state.fadeTimer) {
        clearInterval(state.fadeTimer);
        state.fadeTimer = null;
    }
    const seconds = Math.max(1, Math.min(20, parseFloat(els.fadeSeconds.value) || 4));
    const channels = collectActiveChannels();
    const targets = collectFadeTargets();
    if (!channels.length) return;
    const intervalMs = 30;
    const steps = Math.max(1, Math.floor((seconds * 1000) / intervalMs));
    let step = 0;
    state.fadeState = { active: true, start: Date.now(), durationMs: seconds * 1000 };
    requestDraw();
    state.fadeTimer = setInterval(() => {
        step += 1;
        channels.forEach(ch => {
            const t = targets.get(ch) || { slide: 0, press: 0 };
            const progress = Math.min(1, step / steps);
            const factor = Math.pow(1 - progress, FADE_EASE_POW);
            const slide = Math.max(0, Math.round(t.slide * factor));
            const press = Math.max(0, Math.round(t.press * factor));
            state.midi.output.send([0xB0 + ch - 1, 74, slide]);
            state.midi.output.send([0xD0 + ch - 1, press]);
        });
        if (step >= steps) {
            clearInterval(state.fadeTimer);
            state.fadeTimer = null;
            setTimeout(() => {
                state.fadeState = { active: false, start: 0, durationMs: 0 };
                allNotesOff();
                els.midiStatus.innerText = 'FADE OUT';
            }, FADE_TAIL_MS);
        }
    }, intervalMs);
}

function mapMidiNoteToScale(note) {
    const def = getScaleDefinition();
    const degrees = def.degrees;
    const rel = note - def.root;
    const oct = Math.floor(rel / 12);
    let best = null;
    let bestDist = Infinity;
    for (let o = oct - 1; o <= oct + 1; o++) {
        const base = def.root + (o * 12);
        degrees.forEach(d => {
            const cand = base + d;
            const dist = Math.abs(cand - note);
            if (dist < bestDist) {
                bestDist = dist;
                best = cand;
            }
        });
    }
    return best == null ? note : best;
}

function computeChordNotes(rootNote) {
    const chordMode = els.chordMode.value;
    const rootIdx = state.scaleNotes.notes.indexOf(rootNote);
    let chordNotes = [];
    if (chordMode === 'auto' || chordMode === 'auto7') {
        const diatonic = chordMode === 'auto7' ? [0, 2, 4, 6] : [0, 2, 4];
        if (rootIdx >= 0) {
            chordNotes = diatonic.map(step => state.scaleNotes.notes[rootIdx + step]).filter(n => n !== undefined);
        }
    } else {
        const chordSteps = CHORDS[chordMode] || CHORDS.off;
        chordNotes = chordSteps.map(step => rootNote + step);
    }
    if (chordNotes.length) {
        const snapped = chordNotes.map(note => mapMidiNoteToScale(note));
        const seen = new Set();
        chordNotes = snapped.filter(note => {
            const key = Number.isFinite(note) ? note.toFixed(4) : String(note);
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
        });
    }
    const inversion = parseInt(els.chordInversion.value, 10) || 0;
    const spread = parseInt(els.chordSpread.value, 10) || 0;
    return applyChordVoicing(chordNotes, inversion, spread);
}

function refreshArpNotes(noteObjs, m, rootNote) {
    const chordNotes = computeChordNotes(rootNote);
    if (noteObjs.length > chordNotes.length) {
        const extra = noteObjs.splice(chordNotes.length);
        removeArpNotes(extra);
    } else if (noteObjs.length < chordNotes.length) {
        const add = chordNotes.slice(noteObjs.length).map(noteFloat => ({
            noteFloat,
            ...makeVoiceFromNote(noteFloat),
            lastM: m,
            color: nextArpColor()
        }));
        noteObjs.push(...add);
        state.arp.notes.push(...add);
    }
    for (let i = 0; i < chordNotes.length && i < noteObjs.length; i++) {
        const noteFloat = chordNotes[i];
        const voice = makeVoiceFromNote(noteFloat);
        noteObjs[i].noteFloat = noteFloat;
        noteObjs[i].note = voice.note;
        noteObjs[i].basePb = voice.basePb;
        noteObjs[i].lastM = m;
    }
    return chordNotes;
}

function convertHeldToArp() {
    if (!state.heldVoices.length) return;
    const held = state.heldVoices.slice(0);
    const noteObjs = held.map(v => {
        const noteFloat = getVoiceNoteFloat(v);
        const voice = makeVoiceFromNote(noteFloat);
        return { noteFloat, ...voice, lastM: v.lastM, color: v.color || nextArpColor() };
    });
    const lastM = held[0].lastM;
    const color = held[0].color || '#ffaa00';
    releaseHeldNotes();
    state.arp.notes = noteObjs;
    state.arpHoldTouches = [{ lastM, color, phase: 0, noteObjs }];
    requestDraw();
}

function updateHeldChords() {
    if (!state.heldVoices.length || !state.midi.output) return;
    const groups = new Map();
    state.heldVoices.forEach(v => {
        const groupId = v.group || v.chan || 0;
        if (!groups.has(groupId)) groups.set(groupId, []);
        groups.get(groupId).push(v);
    });
    const nextHeld = [];
    groups.forEach(list => {
        const ref = list[0];
        const rootNote = ref.rootNote;
        if (rootNote == null) {
            nextHeld.push(...list);
            return;
        }
        list.forEach(v => {
            sendMidi([0x80 + v.chan - 1, v.note, 0]);
            state.mpeChannels.push(v.chan);
        });
        state.mpeChannels.sort((a,b)=>a-b);
        const m = ref.lastM || { pbValue: 8192, slide: 0, press: 90 };
        const chordNotes = computeChordNotes(rootNote);
        chordNotes.forEach(noteFloat => {
            const chan = state.mpeChannels.shift();
            if (!chan) return;
            const voice = makeVoiceFromNote(noteFloat);
            const pb = getVoicePb(m, voice);
            sendMidi([0xB0 + chan - 1, 74, m.slide]);
            sendMidi([0xE0 + chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
            sendMidi([0xD0 + chan - 1, m.press]);
            sendMidi([0x90 + chan - 1, voice.note, Math.max(1, Math.min(127, Math.round(m.press || 90)))]);
            nextHeld.push({
                chan,
                note: voice.note,
                basePb: voice.basePb,
                lastM: m,
                color: ref.color,
                phase: ref.phase,
                group: ref.group || 0,
                rootNote
            });
        });
    });
    state.heldVoices = nextHeld;
}

canvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    requestDraw();
    const uiRect = els.ui.getBoundingClientRect();
    const inUi = els.ui.contains(e.target);
    if (!state.midi.output || (els.ui.classList.contains('active') && e.clientY < (uiRect.height + 5)) || inUi) {
        if (!state.midi.output) els.midiStatus.innerText = 'NESSUN MIDI OUT';
        return;
    }
    if (state.groupShiftEnabled) {
        startGroupShiftDrag(e);
        return;
    }
    if (tryStartTwoFingerGroupDrag(e)) return;

    const holdHit = findHeldVoiceAt(e.clientX, e.clientY);
    if (holdHit) {
        const hv = state.heldVoices[holdHit.idx];
        if (hv?.dropActive) return;
        const tapKey = `${hv.chan}:${hv.note}`;
        if (isDoubleTapKey(tapKey, e.clientX, e.clientY)) {
            startHoldDrop(hv);
            return;
        }
        const groupId = hv.group || 0;
        const grabbed = [hv];
        state.heldVoices = state.heldVoices.filter(v => !grabbed.includes(v));
        const tmpVoice = { initialExact: hv.note, lastX: e.clientX, vibratoSpeed: 0 };
        const m = getMPEData(e, tmpVoice);
        grabbed.forEach(gv => {
            const pb = getVoicePb(m, gv);
            sendMidi([0xE0 + gv.chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
            sendMidi([0xB0 + gv.chan - 1, 74, m.slide]);
            sendMidi([0xD0 + gv.chan - 1, m.press]);
        });
        state.activeTouches.set(e.pointerId, { 
            voices: grabbed.map(gv => ({ chan: gv.chan, note: gv.note, basePb: gv.basePb, group: gv.group })), 
            initialExact: hv.rootNote ?? hv.note, lastX: e.clientX, isGrab: false, isHoldGrab: true, holdGroup: groupId,
            vibratoSpeed: 0, phase: hv.phase || 0, color: hv.color, lastM: m 
        });
        if (groupId) {
            const existingEntry = Array.from(state.activeTouches.entries()).find(([id, t]) => t.isHoldGrab && t.holdGroup === groupId && id !== e.pointerId);
            const existing = existingEntry ? existingEntry[1] : null;
            if (existing) {
                const key = getGroupDragKey('hold', groupId);
                startHoldGroupDrag(groupId);
                const cur = state.activeTouches.get(e.pointerId);
                existing.isGroupDrag = true;
                existing.groupDragKey = key;
                if (cur) {
                    cur.isGroupDrag = true;
                    cur.groupDragKey = key;
                }
            }
        }
        return;
    }
    const arpNoteHit = findArpHoldNoteAt(e.clientX, e.clientY);
    if (arpNoteHit) {
        const hold = state.arpHoldTouches[arpNoteHit.holdIdx];
        const noteObj = hold.noteObjs[arpNoteHit.noteIdx];
        if (noteObj?.dropActive) return;
        if (isDoubleTap(noteObj, e.clientX, e.clientY)) {
            startArpHoldDrop(hold, noteObj);
            return;
        }
        const tmpVoice = { initialExact: noteObj.noteFloat ?? noteObj.note, lastX: e.clientX, vibratoSpeed: 0 };
        const m = getMPEData(e, tmpVoice);
        state.activeTouches.set(e.pointerId, { 
            voices: [],
            initialExact: noteObj.noteFloat ?? noteObj.note,
            lastX: e.clientX,
            isGrab: false,
            isArpHoldGrab: true,
            holdIdx: arpNoteHit.holdIdx,
            arpNoteIdx: arpNoteHit.noteIdx,
            arpNoteObj: noteObj,
            vibratoSpeed: 0,
            phase: hold.phase || 0,
            color: noteObj.color || hold.color || '#ffaa00',
            lastM: m
        });
        const existingEntry = Array.from(state.activeTouches.entries()).find(([id, t]) => t.isArpHoldGrab && t.holdIdx === arpNoteHit.holdIdx && id !== e.pointerId);
        const existing = existingEntry ? existingEntry[1] : null;
        if (existing) {
            const key = getGroupDragKey('arp', arpNoteHit.holdIdx);
            startArpGroupDrag(arpNoteHit.holdIdx);
            const cur = state.activeTouches.get(e.pointerId);
            existing.isGroupDrag = true;
            existing.groupDragKey = key;
            if (cur) {
                cur.isGroupDrag = true;
                cur.groupDragKey = key;
            }
        }
        return;
    }
    const arpHoldHit = findArpHoldAt(e.clientX, e.clientY);
    if (arpHoldHit) {
        const hold = state.arpHoldTouches[arpHoldHit.idx];
        const tmpVoice = { initialExact: hold.lastM?.exact ?? 0, lastX: e.clientX, vibratoSpeed: 0 };
        const m = getMPEData(e, tmpVoice);
        state.activeTouches.set(e.pointerId, { 
            voices: [],
            initialExact: hold.lastM?.exact ?? 0,
            lastX: e.clientX,
            isGrab: false,
            isArpHoldGrab: true,
            holdIdx: arpHoldHit.idx,
            vibratoSpeed: 0,
            phase: hold.phase || 0,
            color: hold.color || '#ffaa00',
            lastM: m
        });
        return;
    }

    const touchState = { smoothPb: null, smoothSlide: null, smoothPress: null };
    const m = applySmoothing(touchState, getMPEData(e));

    // STANDALONE: Produzione suono diretta
    const root = parseInt(els.rootNote.value, 10);
    const def = getScaleDefinition();
    const scaleKey = `${def.mode}:${def.name}`;
    if (!state.scaleNotes.notes.length || state.scaleNotes.root !== root || state.scaleNotes.scale !== scaleKey) {
        updateScaleNotes();
    }
    const rootNote = state.scaleNotes.notes.reduce((prev, curr) => Math.abs(curr - m.exact) < Math.abs(prev - m.exact) ? curr : prev);
    const touchColor = `hsl(${(e.pointerId * 47) % 360}, 85%, 55%)`;

    // AUTO-GRAB: Se tocchi una nota gia' attiva fisicamente
    if (state.physicalNotes.has(rootNote)) {
        const list = state.physicalNotes.get(rootNote);
        const pNote = list.find(d => !d.grabbed);
        if (pNote) {
            pNote.grabbed = true;
            state.activeTouches.set(e.pointerId, { 
                voices: [{ chan: pNote.chan, note: rootNote }], 
                initialExact: rootNote, lastX: e.clientX, isGrab: true,
                vibratoSpeed: 0, phase: 0, color: '#00ff44', lastM: m 
            });
            return;
        }
    }

    let voices = [];
    let chordNotes = computeChordNotes(rootNote);
    if (!chordNotes.length) return;
    if (state.arp.enabled && !state.arp.latch) {
        const noteObjs = chordNotes.map(noteFloat => ({
            noteFloat,
            ...makeVoiceFromNote(noteFloat),
            lastM: m,
            color: nextArpColor()
        }));
        state.arp.notes.push(...noteObjs);
        state.activeTouches.set(e.pointerId, {
            voices: noteObjs.map(n => ({ chan: 0, note: n.note, basePb: n.basePb })),
            arpNotes: noteObjs,
            initialExact: rootNote,
            lastX: e.clientX,
            isGrab: false,
            isArp: true,
            vibratoSpeed: 0,
            phase: 0,
            color: touchColor,
            lastM: m,
            smoothPb: touchState.smoothPb,
            smoothSlide: touchState.smoothSlide,
            smoothPress: touchState.smoothPress
        });
        return;
    }
    for(let i=0; i<chordNotes.length; i++) {
        const chan = state.mpeChannels.shift();
        if(chan) {
            const voice = makeVoiceFromNote(chordNotes[i]);
            const pb = getVoicePb(m, voice);
            const vel = Math.max(1, Math.min(127, Math.round(m.press || 90)));
            sendMidi([0xB0 + chan - 1, 74, m.slide]);
            sendMidi([0xE0 + chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
            sendMidi([0x90 + chan - 1, voice.note, vel]);
            markLocalNoteOn(voice.note);
            voices.push({ chan, note: voice.note, basePb: voice.basePb });
        } else {
            els.midiStatus.innerText = 'MPE CHANNELS FULL';
        }
    }
    if (!voices.length) return;
    state.activeTouches.set(e.pointerId, { voices, initialExact: rootNote, lastX: e.clientX, isGrab: false, vibratoSpeed: 0, phase: 0, color: `hsl(${voices[0]?.chan * 25 || 0}, 85%, 55%)`, lastM: m, smoothPb: touchState.smoothPb, smoothSlide: touchState.smoothSlide, smoothPress: touchState.smoothPress });
});

canvas.addEventListener('pointermove', e => {
    const t = state.activeTouches.get(e.pointerId);
    if (!t || !state.midi.output) return;
    requestDraw();
    t.lastX = e.clientX;
    t.lastM = t.lastM ? { ...t.lastM, x: e.clientX, y: e.clientY } : { x: e.clientX, y: e.clientY, press: 0, slide: 0, pbValue: 8192, exact: t.initialExact ?? 0 };
    if (t.isGroupDrag) {
        handleGroupDrag(t);
        return;
    }
    const m = applySmoothing(t, getMPEData(e, t));
    t.lastM = m;
    if (t.isArpHoldGrab) {
        const hold = state.arpHoldTouches[t.holdIdx];
        if (hold) {
            if (t.arpNoteObj) {
                const root = parseInt(els.rootNote.value, 10);
                const def = getScaleDefinition();
                const scaleKey = `${def.mode}:${def.name}`;
                if (!state.scaleNotes.notes.length || state.scaleNotes.root !== root || state.scaleNotes.scale !== scaleKey) {
                    updateScaleNotes();
                }
                const rootNote = state.scaleNotes.notes.reduce((prev, curr) => Math.abs(curr - m.exact) < Math.abs(prev - m.exact) ? curr : prev);
                const voice = makeVoiceFromNote(rootNote);
                t.arpNoteObj.noteFloat = rootNote;
                t.arpNoteObj.note = voice.note;
                t.arpNoteObj.basePb = voice.basePb;
                t.arpNoteObj.lastM = m;
                t.initialExact = rootNote;
                if (m.press <= 0) stopArpActiveNote(t.arpNoteObj.note);
            } else {
                const root = parseInt(els.rootNote.value, 10);
                const def = getScaleDefinition();
                const scaleKey = `${def.mode}:${def.name}`;
                if (!state.scaleNotes.notes.length || state.scaleNotes.root !== root || state.scaleNotes.scale !== scaleKey) {
                    updateScaleNotes();
                }
                const rootNote = state.scaleNotes.notes.reduce((prev, curr) => Math.abs(curr - m.exact) < Math.abs(prev - m.exact) ? curr : prev);
                if (hold.noteObjs) {
                    refreshArpNotes(hold.noteObjs, m, rootNote);
                }
                const pbRange = parseInt(els.pbRange.value, 10) || 12;
                const detune = m.exact - rootNote;
                m.pbValue = clampPb(Math.round(8192 + (detune * (8192 / pbRange))));
                t.initialExact = rootNote;
                hold.lastM = m;
                hold.phase = t.phase;
                hold.color = hold.noteObjs?.[0]?.color || t.color;
                if (m.press <= 0) stopArpActiveNotes(hold.noteObjs);
            }
        }
        return;
    }
    if (t.isArp) {
        if (t.arpNotes) {
            const root = parseInt(els.rootNote.value, 10);
            const def = getScaleDefinition();
            const scaleKey = `${def.mode}:${def.name}`;
            if (!state.scaleNotes.notes.length || state.scaleNotes.root !== root || state.scaleNotes.scale !== scaleKey) {
                updateScaleNotes();
            }
            const rootNote = state.scaleNotes.notes.reduce((prev, curr) => Math.abs(curr - m.exact) < Math.abs(prev - m.exact) ? curr : prev);
            refreshArpNotes(t.arpNotes, m, rootNote);
            const pbRange = parseInt(els.pbRange.value, 10) || 12;
            const detune = m.exact - rootNote;
            m.pbValue = clampPb(Math.round(8192 + (detune * (8192 / pbRange))));
            t.initialExact = rootNote;
            if (m.press <= 0) stopArpActiveNotes(t.arpNotes);
        }
        return;
    }
    t.voices.forEach(v => {
        const pb = getVoicePb(m, v);
        sendMidi([0xE0 + v.chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
        sendMidi([0xB0 + v.chan - 1, 74, m.slide]);
        sendMidi([0xD0 + v.chan - 1, m.press]);
    });
});

canvas.addEventListener('pointerup', e => {
    const t = state.activeTouches.get(e.pointerId);
    if (t) {
        requestDraw();
        const groupKey = t.groupDragKey;
        const hold = els.holdNotes.checked;
        if (t.isArpHoldGrab) {
            const item = state.arpHoldTouches[t.holdIdx];
            if (item) {
                if (t.arpNoteObj) {
                    t.arpNoteObj.lastM = t.lastM;
                } else {
                    item.lastM = t.lastM;
                }
                item.phase = t.phase;
                item.color = item.noteObjs?.[0]?.color || t.color;
            }
            state.activeTouches.delete(e.pointerId);
            cleanupGroupDrag(groupKey);
            return;
        }
        if (!t.isGrab && !t.isArp && els.quantizeRelease.checked) {
            const snapM = getMPEData(e, t, true);
            t.lastM = snapM;
            t.voices.forEach(v => {
                const pb = getVoicePb(snapM, v);
                sendMidi([0xE0 + v.chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
                sendMidi([0xB0 + v.chan - 1, 74, snapM.slide]);
                sendMidi([0xD0 + v.chan - 1, snapM.press]);
            });
        }
        if (t.isArp) {
            const keep = hold;
            if (!keep) {
                stopArpActiveNotes(t.arpNotes);
                removeArpNotes(t.arpNotes);
            } else {
                const holdColor = t.arpNotes?.[0]?.color || t.color;
                state.arpHoldTouches.push({ lastM: t.lastM, color: holdColor, phase: t.phase || 0, noteObjs: t.arpNotes });
            }
            state.activeTouches.delete(e.pointerId);
            cleanupGroupDrag(groupKey);
            return;
        }
        if (t.isHoldGrab) {
            if (hold) {
                snapHoldVoicesToScale(t);
                const groupId = t.holdGroup || state.holdGroupSeq++;
                t.voices.forEach(v => {
                    state.heldVoices.push({ chan: v.chan, note: v.note, basePb: v.basePb, lastM: t.lastM, color: t.color, phase: t.phase, group: groupId, rootNote: t.initialExact });
                });
            } else {
                t.voices.forEach(v => {
                    sendMidi([0x80 + v.chan - 1, v.note, 0]);
                    state.mpeChannels.push(v.chan);
                });
            }
            state.mpeChannels.sort((a,b)=>a-b);
            state.activeTouches.delete(e.pointerId);
            cleanupGroupDrag(groupKey);
            return;
        }
        if (!t.isGrab && hold) {
            snapHoldVoicesToScale(t);
        }
        t.voices.forEach(v => {
            if(!t.isGrab) {
                if (hold) {
                    const groupId = t.holdGroup || state.holdGroupSeq++;
                    sendMidi([0xB0 + v.chan - 1, 74, t.lastM.slide]);
                    sendMidi([0xD0 + v.chan - 1, t.lastM.press]);
                    state.heldVoices.push({ chan: v.chan, note: v.note, basePb: v.basePb, lastM: t.lastM, color: t.color, phase: t.phase, group: groupId, rootNote: t.initialExact });
                    t.holdGroup = groupId;
                } else {
                    sendMidi([0x80 + v.chan - 1, v.note, 0]);
                    state.mpeChannels.push(v.chan);
                }
            } else {
                if (state.physicalNotes.has(v.note)) {
                    const list = state.physicalNotes.get(v.note);
                    const pNote = list.find(d => d.chan === v.chan);
                    if (pNote) {
                        pNote.grabbed = false;
                        const pb = pNote.lastPb || 8192;
                        sendMidi([0xE0 + v.chan - 1, pb & 0x7F, (pb >> 7) & 0x7F]);
                        sendMidi([0xB0 + v.chan - 1, 74, pNote.lastSlide || 0]);
                        sendMidi([0xD0 + v.chan - 1, pNote.lastPress || 0]);
                    }
                }
            }
        });
        if (!hold) state.mpeChannels.sort((a,b)=>a-b);
        state.activeTouches.delete(e.pointerId);
        cleanupGroupDrag(groupKey);
    }
});

function cancelActivePointer(pointerId) {
    const t = state.activeTouches.get(pointerId);
    if (!t) return;
    const groupKey = t.groupDragKey;
    if (t.isArp) {
        const keep = els.holdNotes.checked;
        if (!keep) removeArpNotes(t.arpNotes);
        state.activeTouches.delete(pointerId);
        cleanupGroupDrag(groupKey);
        return;
    }
    if (!state.midi.output) {
        state.activeTouches.delete(pointerId);
        cleanupGroupDrag(groupKey);
        return;
    }
    t.voices.forEach(v => {
        sendMidi([0x80 + v.chan - 1, v.note, 0]);
        state.mpeChannels.push(v.chan);
    });
    state.mpeChannels.sort((a,b)=>a-b);
    state.activeTouches.delete(pointerId);
    cleanupGroupDrag(groupKey);
}

canvas.addEventListener('pointercancel', e => cancelActivePointer(e.pointerId));
canvas.addEventListener('pointerleave', e => cancelActivePointer(e.pointerId));

const uiToggle = document.getElementById('uiToggle');
const perfToggle = document.getElementById('perfToggle');
 

function setupChordKnob() {
    const select = els.chordMode;
    const wheel = els.chordWheel;
    const options = Array.from(select.options);
    let currentIndex = Math.max(0, options.findIndex(o => o.value === select.value));
    let lastModeValue = select.value !== 'off' ? select.value : 'triad';
    let lastAngle = null;
    let angleAccum = 0;
    let didRotate = false;
    const stepAngle = 30;

    function applyIndex(idx) {
        currentIndex = Math.max(0, Math.min(options.length - 1, idx));
        select.selectedIndex = currentIndex;
        const isOn = select.value !== 'off';
        if (isOn) lastModeValue = select.value;
        wheel.innerText = options[currentIndex].text;
        wheel.classList.toggle('knob-on', isOn);
        wheel.classList.toggle('knob-off', !isOn);
    }

    select.addEventListener('change', () => {
        applyIndex(select.selectedIndex);
        updateHeldChords();
    });

    function toggleChord() {
        if (select.value === 'off') {
            const idx = Math.max(0, options.findIndex(o => o.value === lastModeValue));
            applyIndex(idx);
        } else {
            applyIndex(0);
        }
        updateHeldChords();
    }

    function angleFromEvent(e) {
        const rect = wheel.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        return Math.atan2(e.clientY - cy, e.clientX - cx) * (180 / Math.PI);
    }

    function stepBy(delta) {
        let nextIdx = currentIndex + delta;
        if (nextIdx < 0) nextIdx = options.length - 1;
        if (nextIdx >= options.length) nextIdx = 0;
        if (options[nextIdx].value === 'off') {
            nextIdx = delta > 0 ? (nextIdx + 1) % options.length : (nextIdx - 1 + options.length) % options.length;
        }
        didRotate = true;
        applyIndex(nextIdx);
        updateHeldChords();
    }

    wheel.addEventListener('pointerdown', e => {
        e.preventDefault();
        requestDraw();
        wheel.setPointerCapture(e.pointerId);
        lastAngle = angleFromEvent(e);
        angleAccum = 0;
        didRotate = false;
        wheel.classList.add('active');
    });
    wheel.addEventListener('pointermove', e => {
        if (lastAngle == null) return;
        requestDraw();
        const ang = angleFromEvent(e);
        let delta = ang - lastAngle;
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;
        angleAccum += delta;
        lastAngle = ang;
        while (angleAccum >= stepAngle) {
            stepBy(1);
            angleAccum -= stepAngle;
        }
        while (angleAccum <= -stepAngle) {
            stepBy(-1);
            angleAccum += stepAngle;
        }
    });
    wheel.addEventListener('pointerup', e => {
        wheel.releasePointerCapture(e.pointerId);
        lastAngle = null;
        angleAccum = 0;
        if (!didRotate) toggleChord();
        wheel.classList.toggle('knob-on', select.value !== 'off');
        wheel.classList.toggle('knob-off', select.value === 'off');
        requestDraw();
    });
    wheel.addEventListener('pointercancel', () => {
        lastAngle = null;
        angleAccum = 0;
        wheel.classList.toggle('knob-on', select.value !== 'off');
        wheel.classList.toggle('knob-off', select.value === 'off');
    });
    applyIndex(currentIndex);
}

function setupArpKnob() {
    const select = els.arpRate;
    const wheel = els.arpWheel;
    const options = Array.from(select.options);
    let currentIndex = Math.max(0, options.findIndex(o => o.value === select.value));
    let lastAngle = null;
    let angleAccum = 0;
    let didRotate = false;
    const stepAngle = 30;

    function applyIndex(idx) {
        currentIndex = Math.max(0, Math.min(options.length - 1, idx));
        select.selectedIndex = currentIndex;
        updateArpControlsUI();
        syncArpFromUI();
    }

    select.addEventListener('change', () => {
        currentIndex = select.selectedIndex;
        updateArpControlsUI();
    });

    function toggleArp() {
        els.arpEnabled.checked = !els.arpEnabled.checked;
        syncArpFromUI();
    }

    function angleFromEvent(e) {
        const rect = wheel.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        return Math.atan2(e.clientY - cy, e.clientX - cx) * (180 / Math.PI);
    }

    function stepBy(delta) {
        let nextIdx = currentIndex + delta;
        if (nextIdx < 0) nextIdx = options.length - 1;
        if (nextIdx >= options.length) nextIdx = 0;
        didRotate = true;
        applyIndex(nextIdx);
    }

    wheel.addEventListener('pointerdown', e => {
        e.preventDefault();
        requestDraw();
        wheel.setPointerCapture(e.pointerId);
        lastAngle = angleFromEvent(e);
        angleAccum = 0;
        didRotate = false;
        wheel.classList.add('active');
    });
    wheel.addEventListener('pointermove', e => {
        if (lastAngle == null) return;
        requestDraw();
        const ang = angleFromEvent(e);
        let delta = ang - lastAngle;
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;
        angleAccum += delta;
        lastAngle = ang;
        while (angleAccum >= stepAngle) {
            stepBy(1);
            angleAccum -= stepAngle;
        }
        while (angleAccum <= -stepAngle) {
            stepBy(-1);
            angleAccum += stepAngle;
        }
    });
    wheel.addEventListener('pointerup', e => {
        wheel.releasePointerCapture(e.pointerId);
        lastAngle = null;
        angleAccum = 0;
        if (!didRotate) toggleArp();
        wheel.classList.toggle('knob-on', els.arpEnabled.checked);
        wheel.classList.toggle('knob-off', !els.arpEnabled.checked);
        requestDraw();
    });
    wheel.addEventListener('pointercancel', () => {
        lastAngle = null;
        angleAccum = 0;
        wheel.classList.toggle('knob-on', els.arpEnabled.checked);
        wheel.classList.toggle('knob-off', !els.arpEnabled.checked);
    });
    updateArpControlsUI();
}

function findHeldVoiceAt(x, y) {
    for (let i = state.heldVoices.length - 1; i >= 0; i--) {
        const m = state.heldVoices[i].lastM;
        if (!m) continue;
        const radius = 12 + (m.press / 127) * 22;
        const noteFloat = getVoiceNoteFloat(state.heldVoices[i]);
        const px = getNearestNoteX(noteFloat) ?? m.x;
        const py = m.y;
        const dx = x - px;
        const dy = y - py;
        if ((dx * dx + dy * dy) <= ((radius + 10) * (radius + 10))) {
            return { idx: i };
        }
    }
    return null;
}

function findArpHoldNoteAt(x, y) {
    for (let i = state.arpHoldTouches.length - 1; i >= 0; i--) {
        const hold = state.arpHoldTouches[i];
        if (!hold || !hold.noteObjs) continue;
        for (let n = hold.noteObjs.length - 1; n >= 0; n--) {
            const noteObj = hold.noteObjs[n];
            const m = noteObj.lastM || hold.lastM;
            if (!m) continue;
            const radius = 10 + (m.press / 127) * 18;
            const px = getNearestNoteX(noteObj.noteFloat ?? noteObj.note) ?? m.x;
            const py = m.y;
            const dx = x - px;
            const dy = y - py;
            if ((dx * dx + dy * dy) <= ((radius + 10) * (radius + 10))) {
                return { holdIdx: i, noteIdx: n };
            }
        }
    }
    return null;
}

function findArpHoldAt(x, y) {
    for (let i = state.arpHoldTouches.length - 1; i >= 0; i--) {
        const m = state.arpHoldTouches[i].lastM;
        if (!m) continue;
        const radius = 10 + (m.press / 127) * 18;
        const dx = x - m.x;
        const dy = y - m.y;
        if ((dx * dx + dy * dy) <= ((radius + 10) * (radius + 10))) {
            return { idx: i };
        }
    }
    return null;
}

state.presets = loadPresets();
state.mpePresets = loadMpePresets();
state.customScales = loadCustomScales();
if (!Object.keys(state.presets).length) {
    const base = getPresetState();
    state.presets = {
        Init: base,
        Ableton: {
            ...base,
            arpSync: 'midi',
            smoothAmt: '20',
            curveType: 'soft',
            yDeadzone: '5',
            arpLatch: false,
            quantizeRelease: true
        },
        Expressive: {
            ...base,
            roundRate: '10',
            deadCenter: false,
            deadCenterForce: '30',
            smoothAmt: '10',
            curveType: 'linear',
            yDeadzone: '2',
            quantizeRelease: false
        },
        Tight: {
            ...base,
            roundRate: '80',
            deadCenter: true,
            deadCenterForce: '100',
            smoothAmt: '35',
            curveType: 'soft',
            yDeadzone: '8',
            quantizeRelease: true
        },
        Glide: {
            ...base,
            roundRate: '0',
            deadCenter: false,
            deadCenterForce: '0',
            smoothAmt: '5',
            curveType: 'linear',
            yDeadzone: '0',
            quantizeRelease: false
        }
    };
} else if (state.presets.Init) {
    state.presets.Init.visibleOctaves = "1";
}
savePresets(state.presets);
refreshPresetSelect(state.presets, 'Init');
if (!Object.keys(state.mpePresets).length) {
    const mpeBase = getMpePresetState();
    state.mpePresets = {
        Expressive: { ...mpeBase, roundRate: '10', deadCenter: false, deadCenterForce: '30', smoothAmt: '10', curveType: 'linear', yDeadzone: '2', quantizeRelease: false },
        Tight: { ...mpeBase, roundRate: '80', deadCenter: true, deadCenterForce: '100', smoothAmt: '35', curveType: 'soft', yDeadzone: '8', quantizeRelease: true },
        Glide: { ...mpeBase, roundRate: '0', deadCenter: false, deadCenterForce: '0', smoothAmt: '5', curveType: 'linear', yDeadzone: '0', quantizeRelease: false }
    };
}
saveMpePresets(state.mpePresets);
refreshMpePresetSelect(state.mpePresets, 'Tight');
populateMicrotonalSelect();
state.customScales = { ...DEFAULT_CUSTOM_SCALES, ...state.customScales };
saveCustomScales(state.customScales);
const firstCustom = Object.keys(state.customScales)[0];
els.customScaleName.value = firstCustom || '';
loadCustomScaleByName(firstCustom);
refreshCustomScaleDatalist();
function bindUI() {
    els.presetSelect.onchange = e => {
        const presetState = state.presets[e.target.value];
        applyPresetState(presetState);
        updatePresetDescription(e.target.value);
    };
    els.presetSave.onclick = () => {
        const name = els.presetName.value.trim() || els.presetSelect.value || 'Preset';
        state.presets[name] = getPresetState();
        savePresets(state.presets);
        refreshPresetSelect(state.presets, name);
        updatePresetDescription(name);
    };
    els.presetDel.onclick = () => {
        const sel = els.presetSelect.value;
        if (sel && sel !== 'Init') {
            delete state.presets[sel];
            savePresets(state.presets);
            refreshPresetSelect(state.presets, 'Init');
            applyPresetState(state.presets.Init);
            updatePresetDescription('Init');
        }
    };
    els.mpePresetSelect.onchange = e => {
        const mpePresetState = state.mpePresets[e.target.value];
        applyMpePresetState(mpePresetState);
        updateMpePresetDescription(e.target.value);
    };
    els.mpePresetSave.onclick = () => {
        const name = els.mpePresetName.value.trim() || els.mpePresetSelect.value || 'MPE Preset';
        state.mpePresets[name] = getMpePresetState();
        saveMpePresets(state.mpePresets);
        refreshMpePresetSelect(state.mpePresets, name);
        updateMpePresetDescription(name);
    };
    els.mpePresetDel.onclick = () => {
        const sel = els.mpePresetSelect.value;
        if (sel) {
            delete state.mpePresets[sel];
            saveMpePresets(state.mpePresets);
            refreshMpePresetSelect(state.mpePresets, 'Tight');
        }
    };
    els.customScaleSave.onclick = () => {
        const name = els.customScaleName.value.trim();
        if (!name) return;
        if (els.customModeNotes.checked) {
            const degrees = parseNotesList(els.customScaleNotes.value);
            if (degrees.length < 2) return;
            state.customScales[name] = { type: 'notes', degrees };
        } else {
            const cents = parseCentsList(els.customScaleCents.value);
            if (cents.length < 2) return;
            state.customScales[name] = { type: 'cents', cents };
        }
        saveCustomScales(state.customScales);
        els.scaleModeCustom.checked = true;
        els.customScaleName.value = name;
        refreshCustomScaleDatalist();
        updateScaleModeUI();
        updateScaleNotes();
    };
    els.customScaleDel.onclick = () => {
        const sel = els.customScaleName.value.trim();
        if (sel) {
            delete state.customScales[sel];
            saveCustomScales(state.customScales);
            const next = Object.keys(state.customScales)[0] || '';
            els.customScaleName.value = next;
            if (next) loadCustomScaleByName(next);
            else els.customScaleCents.value = '';
            refreshCustomScaleDatalist();
            updateScaleNotes();
        }
    };
    uiToggle.onclick = () => {
        els.ui.classList.toggle('active');
        refreshLayout();
    };
    if (els.uiAdvancedToggle) {
        els.uiAdvancedToggle.onclick = () => {
            els.ui.classList.toggle('show-advanced');
            refreshLayout();
        };
    }
    perfToggle.onclick = () => {
        els.performance.classList.toggle('collapsed');
        refreshLayout();
    };
    els.fsBtn.onclick = () => {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else document.exitFullscreen();
    };
    els.octDownBtn.onclick = () => changeOctave(-1);
    els.octUpBtn.onclick = () => changeOctave(1);
    els.holdBtn.onclick = () => {
        const hold = els.holdNotes;
        hold.checked = !hold.checked;
        updateHoldButtonUI();
        if (!hold.checked) {
            releaseHeldNotes();
            if (state.groupShiftEnabled) {
                state.groupShiftEnabled = false;
                updateGroupShiftUI();
            }
        }
    };
    els.pbRange.onchange = e => setPitchBendRange(parseInt(e.target.value, 10));
    els.holdNotes.onchange = e => {
        updateHoldButtonUI();
        if (!e.target.checked) {
            releaseHeldNotes();
            if (state.groupShiftEnabled) {
                state.groupShiftEnabled = false;
                updateGroupShiftUI();
            }
        }
    };
    els.panicBtn.onclick = () => {
        if (state.groupShiftEnabled) {
            state.groupShiftEnabled = false;
            updateGroupShiftUI();
        }
        allNotesOff();
        els.midiStatus.innerText = 'STOP';
    };
    els.fadeBtn.onclick = () => {
        if (state.groupShiftEnabled) {
            state.groupShiftEnabled = false;
            updateGroupShiftUI();
        }
        fadeOutAll();
    };
    els.arpEnabled.onchange = syncArpFromUI;
    els.arpRate.onchange = syncArpFromUI;
    els.arpGate.onchange = syncArpFromUI;
    els.arpSync.onchange = syncArpFromUI;
    els.arpBpm.onchange = syncArpFromUI;
    els.arpLatch.onchange = syncArpFromUI;
    els.arpParamsToggle.onclick = () => {
        els.arpParamsPanel.classList.toggle('hidden');
        updateArpParamsToggleLabel();
    };
    els.groupShiftBtn.onclick = () => {
        state.groupShiftEnabled = !state.groupShiftEnabled;
        updateGroupShiftUI();
    };
    els.rootNote.onchange = scheduleScaleUpdate;
    els.scaleType.onchange = () => {
        els.scaleModeDiatonic.checked = true;
        updateScaleModeUI();
        scheduleScaleUpdate();
    };
    els.microScaleSelect.onchange = () => {
        els.scaleModeMicro.checked = true;
        updateScaleModeUI();
        scheduleScaleUpdate();
    };
    els.customScaleCents.onchange = () => {
        els.scaleModeCustom.checked = true;
        updateScaleModeUI();
        scheduleScaleUpdate();
    };
    els.customModeNotes.onchange = () => { updateScaleModeUI(); scheduleScaleUpdate(); };
    els.customModeCents.onchange = () => { updateScaleModeUI(); scheduleScaleUpdate(); };
    els.customScaleNotes.onchange = () => {
        els.scaleModeCustom.checked = true;
        updateScaleModeUI();
        scheduleScaleUpdate();
    };
    els.customScaleName.onchange = () => {
        const name = els.customScaleName.value.trim();
        if (name && state.customScales[name]) {
            loadCustomScaleByName(name);
        }
        els.scaleModeCustom.checked = true;
        updateScaleModeUI();
        scheduleScaleUpdate();
    };
    els.customScaleSaved.onchange = () => {
        const name = els.customScaleSaved.value;
        if (name) {
            els.customScaleName.value = name;
            loadCustomScaleByName(name);
            els.scaleModeCustom.checked = true;
            updateScaleModeUI();
            scheduleScaleUpdate();
        }
    };
    els.scaleModeDiatonic.onchange = () => { updateScaleModeUI(); scheduleScaleUpdate(); };
    els.scaleModeMicro.onchange = () => { updateScaleModeUI(); scheduleScaleUpdate(); };
    els.scaleModeCustom.onchange = () => { updateScaleModeUI(); scheduleScaleUpdate(); };
    els.microtonalizeIn.onchange = () => { updateScaleModeUI(); scheduleScaleUpdate(); };
    document.querySelectorAll('[data-scale-choice]').forEach(choice => {
        choice.onclick = () => {
            const mode = choice.getAttribute('data-scale-choice');
            if (mode === 'microtonal') els.scaleModeMicro.checked = true;
            else if (mode === 'custom') els.scaleModeCustom.checked = true;
            else els.scaleModeDiatonic.checked = true;
            updateScaleModeUI();
            scheduleScaleUpdate();
        };
    });
}

bindUI();
setupChordKnob();
setupArpKnob();

function scheduleScaleUpdate() {
    if (state.scaleUpdateRaf != null) return;
    state.scaleUpdateRaf = requestAnimationFrame(() => {
        state.scaleUpdateRaf = null;
        updateScaleNotes();
    });
}

function updateScaleNotes() {
    const def = getScaleDefinition();
    const notes = [];
    const degrees = def.degrees;
    for (let oct = -1; oct <= 11; oct++) {
        degrees.forEach(d => {
            const note = (oct * 12) + def.root + d;
            if (note >= 0 && note <= 127) notes.push(note);
        });
    }
    notes.sort((a, b) => a - b);
    state.scaleNotes = { notes, root: def.root, scale: `${def.mode}:${def.name}` };
    requestDraw();
}

function shouldAnimate() {
    return !document.hidden && (
        state.fadeState.active ||
        state.activeTouches.size ||
        state.heldVoices.length ||
        state.arpHoldTouches.length ||
        state.arp.active.length ||
        state.physicalNotes.size
    );
}

function requestDraw() {
    if (document.hidden) return;
    if (state.drawRaf == null) state.drawRaf = requestAnimationFrame(draw);
}

function getFadeState() {
    let fadeMul = 1;
    if (state.fadeState.active) {
        const elapsed = Date.now() - state.fadeState.start;
        const progress = Math.min(1, elapsed / Math.max(1, state.fadeState.durationMs));
        fadeMul = Math.max(0, Math.pow(1 - progress, FADE_EASE_POW));
    }
    return { fadeMul, fadeDrop: 1 - fadeMul };
}

function collectHighlightMaps() {
    const chordHighlightNotes = new Map();
    const chordDimNotes = new Set();
    const arpActiveNotes = new Map();
    state.activeTouches.forEach(t => {
        if (t.isHoldGrab) {
            const target = mapMidiNoteToScale(t.lastM?.exact ?? 0);
            const source = mapMidiNoteToScale(t.initialExact ?? 0);
            if (Number.isFinite(source)) chordDimNotes.add(Math.round(source));
            if (Number.isFinite(target)) chordHighlightNotes.set(Math.round(target), t.color);
        }
        if (t.isArp && t.arpNotes) {
            t.arpNotes.forEach(n => chordHighlightNotes.set(Math.round(n.note), t.color));
        } else {
            t.voices.forEach(v => {
                const noteFloat = getVoiceNoteFloat(v);
                chordHighlightNotes.set(Math.round(noteFloat), t.color);
            });
        }
    });
    state.heldVoices.forEach(v => {
        const noteFloat = getVoiceNoteFloat(v);
        chordHighlightNotes.set(Math.round(noteFloat), v.color);
    });
    state.arp.notes.forEach(n => chordHighlightNotes.set(Math.round(n.note), n.color));
    state.arp.active.forEach(entry => arpActiveNotes.set(entry.note, entry.color));
    return { chordHighlightNotes, chordDimNotes, arpActiveNotes };
}

function drawGridCells(width, height, grid, numOct, noteW, baseMIDI, fadeMul, fadeDrop, time, maps) {
    const { chordHighlightNotes, chordDimNotes, arpActiveNotes } = maps;
    if (state.gridCache?.bgCanvas) ctx.drawImage(state.gridCache.bgCanvas, 0, 0);
    for (let i = 0; i < (numOct * grid.stepsPerOct); i++) {
        const n = getGridNoteAt(i, grid.degrees, baseMIDI);
        const x = i * noteW;
        const nRound = Math.round(n);
        if (chordDimNotes.has(nRound)) {
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = '#000';
            ctx.fillRect(x, 0, noteW, height);
            ctx.globalAlpha = 1;
        }
        if (chordHighlightNotes.has(nRound)) {
            const color = chordHighlightNotes.get(nRound) || '#ffaa00';
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = color;
            ctx.fillRect(x, 0, noteW, height);
            ctx.globalAlpha = 1;
        }
        if (arpActiveNotes.has(nRound)) {
            const color = arpActiveNotes.get(nRound) || '#00ff77';
            ctx.globalAlpha = 0.45;
            ctx.fillStyle = color;
            ctx.fillRect(x, 0, noteW, height);
            ctx.globalAlpha = 1;
        }
        const pList = state.physicalNotes.get(nRound);
        const pData = pList ? pList.find(d => !d.grabbed && d.onTs && (time - d.onTs) <= GHOST_NOTE_MS) : null;
        if (pData) {
            const rad = 20 + Math.sin(time/200)*5;
            const yBase = height / 2;
            const y = yBase + ((height - yBase) * fadeDrop);
            ctx.globalAlpha = fadeMul;
            ctx.beginPath(); ctx.strokeStyle = '#00ff44'; ctx.lineWidth = 3;
            ctx.arc(x + noteW/2, y, rad, 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle = 'rgba(0,255,70,0.2)'; ctx.fill();
            ctx.globalAlpha = 1;
        }
    }
}

function drawHeldVoices(fadeMul, fadeDrop, height) {
    if (!state.heldVoices.length) return;
    state.heldVoices.forEach((v, i) => {
        const m = v.lastM;
        const radius = 12 + (m.press / 127) * 22;
        v.phase = (v.phase || 0) + 0.2;
        const noteFloat = getVoiceNoteFloat(v);
        const x = getNearestNoteX(noteFloat) ?? m.x;
        const y = m.y + ((height - m.y) * fadeDrop);
        ctx.globalAlpha = fadeMul;
        ctx.beginPath(); ctx.strokeStyle = v.color; ctx.lineWidth = 3;
        for (let ox = -50; ox <= 50; ox += 2) {
            const oy = Math.sin(ox * 0.15 + v.phase) * 3;
            if (ox === -50) ctx.moveTo(x + ox, y + oy);
            else ctx.lineTo(x + ox, y + oy);
        }
        ctx.stroke();
        drawNoteBubble(x, y, radius, v.color, i === 0 ? "HOLD" : null);
        ctx.globalAlpha = 1;
    });
}

function drawArpHoldTouches(fadeMul, fadeDrop, height) {
    if (!state.arpHoldTouches.length) return;
    state.arpHoldTouches.forEach(t => {
        const list = t.noteObjs || [];
        list.forEach((n, idx) => {
            const m = n.lastM || t.lastM;
            if (!m) return;
            const radius = 10 + (m.press / 127) * 18;
            t.phase = (t.phase || 0) + 0.2;
            const x = getNearestNoteX(n.noteFloat ?? n.note) ?? m.x;
            const y = m.y + ((height - m.y) * fadeDrop);
            const glow = n.color || t.color || '#ffaa00';
            ctx.globalAlpha = fadeMul;
            drawNoteBubble(x, y, radius, glow, idx === 0 ? "ARP HOLD" : null);
            ctx.globalAlpha = 1;
        });
    });
}

function drawActiveTouches(fadeMul, fadeDrop, height) {
    state.activeTouches.forEach(t => {
        const radius = 12 + (t.lastM.press / 127) * 22;
        t.phase += 0.2 + (t.vibratoSpeed * 0.06);
        const y = t.lastM.y + ((height - t.lastM.y) * fadeDrop);
        ctx.globalAlpha = fadeMul;
        ctx.beginPath(); ctx.strokeStyle = t.color; ctx.lineWidth = 3;
        for (let ox = -50; ox <= 50; ox += 2) {
            const oy = Math.sin(ox * 0.15 + t.phase) * (4 + t.vibratoSpeed);
            if (ox === -50) ctx.moveTo(t.lastM.x + ox, y + oy);
            else ctx.lineTo(t.lastM.x + ox, y + oy);
        }
        ctx.stroke();
        const label = t.isGrab
            ? "GRAB"
            : (t.isGroupDrag ? "GROUP" : (t.isArpHoldGrab ? "ARP HOLD" : (t.isArp ? "ARP" : `CH${t.voices[0].chan}`)));
        drawNoteBubble(t.lastM.x, y, radius, t.color, label);
        if (t.isArp && t.arpNotes) {
            t.arpNotes.forEach(n => {
                const noteFloat = n.noteFloat ?? n.note;
                const nx = getNearestNoteX(noteFloat) ?? t.lastM.x;
                drawNoteBubble(nx, y, Math.max(8, radius * 0.7), n.color || t.color, null);
            });
        } else if (t.voices && t.voices.length > 1) {
            t.voices.forEach(v => {
                const noteFloat = getVoiceNoteFloat(v);
                const nx = getNearestNoteX(noteFloat) ?? t.lastM.x;
                drawNoteBubble(nx, y, Math.max(8, radius * 0.7), t.color, null);
            });
        }
        ctx.globalAlpha = 1;
    });
}

function draw() {
    state.drawRaf = null;
    const width = Math.floor(state.canvasRect.width);
    const height = Math.floor(state.canvasRect.height);
    ctx.fillStyle = '#000'; ctx.fillRect(0, 0, width, height);
    const { fadeMul, fadeDrop } = getFadeState();
    const numOct = parseInt(els.visibleOctaves.value, 10);
    const grid = getGridDegrees();
    const noteW = width / (numOct * grid.stepsPerOct);
    const baseMIDI = 48 + (state.currentOctave * 12) + grid.root;
    updateGridCache();
    const time = Date.now();
    const maps = collectHighlightMaps();
    drawGridCells(width, height, grid, numOct, noteW, baseMIDI, fadeMul, fadeDrop, time, maps);
    drawHeldVoices(fadeMul, fadeDrop, height);
    drawArpHoldTouches(fadeMul, fadeDrop, height);
    drawActiveTouches(fadeMul, fadeDrop, height);
    if (shouldAnimate()) requestDraw();
}

function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    state.canvasRect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(state.canvasRect.width * dpr);
    canvas.height = Math.floor(state.canvasRect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function updateLayoutVars() {
    const uiRect = els.ui.getBoundingClientRect();
    const perfRect = els.performance.getBoundingClientRect();
    const isActive = els.ui.classList.contains('active');
    const isPerfCollapsed = els.performance.classList.contains('collapsed');
    const uiH = isActive ? uiRect.height : 0;
    const perfH = isPerfCollapsed ? 0 : perfRect.height;
    state.perfHeight = perfH;
    document.documentElement.style.setProperty('--ui-h', `${uiH}px`);
    document.documentElement.style.setProperty('--perf-h', `${perfH}px`);
}

function refreshLayout() {
    updateLayoutVars();
    resizeCanvas();
    updateToggleLabels();
    requestDraw();
}

window.onresize = refreshLayout;
document.addEventListener('visibilitychange', () => {
    if (!document.hidden) requestDraw();
});
els.ui.addEventListener('transitionend', refreshLayout);
els.performance.addEventListener('transitionend', refreshLayout);
refreshLayout(); updateScaleModeUI(); updateScaleNotes(); syncArpFromUI(); updateHoldButtonUI(); updateArpParamsToggleLabel(); updateGroupShiftUI(); setupMIDI(); draw();

function updateToggleLabels() {
    const uiLabel = uiToggle.querySelector('.btn-text');
    const perfLabel = perfToggle.querySelector('.btn-text');
    const advLabel = els.uiAdvancedToggle?.querySelector('.btn-text');
    if (uiLabel) uiLabel.textContent = els.ui.classList.contains('active') ? 'X' : 'SET';
    if (perfLabel) perfLabel.textContent = els.performance.classList.contains('collapsed') ? 'PLAY' : 'X';
    if (advLabel) advLabel.textContent = els.ui.classList.contains('show-advanced') ? 'X' : 'ADV';
}
</script>
</body>
</html>








